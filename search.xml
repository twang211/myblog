<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[[收藏] 如何用纯js(angular)写一个返回顶部的按钮?]]></title>
      <url>/2017/12/12/%E6%94%B6%E8%97%8F-%E5%A6%82%E4%BD%95%E7%94%A8%E7%BA%AFjs-angular-%E5%86%99%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E7%9A%84%E6%8C%89%E9%92%AE/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.getElementById(&quot;btn&quot;).onclick=function()&#123;</div><div class="line">    window.scrollTo(0,0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(window).scroll(function() &#123;</div><div class="line">  if ($(window).scrollTop() &gt; 100) &#123;</div><div class="line">  $(&quot;#back-to-top&quot;).fadeIn(1500);</div><div class="line">  &#125; else &#123;</div><div class="line">  $(&quot;#back-to-top&quot;).fadeOut(1500);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">js: window.scrollTo(0,0); //直接上移</div><div class="line">jq: $(document).animate(&#123;</div><div class="line">       scrollTop: &quot;0px&quot;</div><div class="line">    &#125;, 1000);  //带运动上移</div><div class="line">html: 锚点 //直接上移</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 常见问题 </tag>
            
            <tag> Angular </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[收藏]自适应屏幕轮播图详解]]></title>
      <url>/2017/10/10/%E6%94%B6%E8%97%8F-%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%8F%E5%B9%95%E8%BD%AE%E6%92%AD%E5%9B%BE%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>相应的工具:</p>
<ul>
<li>bootstrap</li>
<li>jQuery</li>
</ul>
<p>材料：</p>
<ul>
<li>4张640x340的图片</li>
<li>4张2000x410内容相同的图片</li>
</ul>
<p>原理及实现方法:</p>
<ol>
<li><p>当屏幕宽度大于等于768px时，图片使用大图，轮播图里的div高度固定，宽度为窗口的宽度(随窗口宽度的变化而变化)</p>
</li>
<li><p>当屏幕宽度小于768px（手机）时，将图片换为小图，并在div里生成img标签，img的宽高随窗口变化而变化，包裹img的div也随之变化</p>
</li>
<li><p>html代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;section id=&quot;main_ad&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt;</div><div class="line">    &lt;!-- 活动指示器 --&gt;</div><div class="line">    &lt;ol class=&quot;carousel-indicators&quot;&gt;</div><div class="line">      &lt;li data-target=&quot;#main_ad&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt;</div><div class="line">      &lt;li data-target=&quot;#main_ad&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt;</div><div class="line">      &lt;li data-target=&quot;#main_ad&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;</div><div class="line">      &lt;li data-target=&quot;#main_ad&quot; data-slide-to=&quot;3&quot;&gt;&lt;/li&gt;</div><div class="line">    &lt;/ol&gt;</div><div class="line">    &lt;!-- 轮播项 --&gt;</div><div class="line">    &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt;</div><div class="line">      &lt;div class=&quot;item active&quot; data-image-lg=&quot;img/slide_01_2000x410.jpg&quot; data-image-xs=&quot;img/slide_01_640x340.jpg&quot;&gt;&lt;/div&gt;</div><div class="line">      &lt;div class=&quot;item&quot; data-image-lg=&quot;img/slide_02_2000x410.jpg&quot; data-image-xs=&quot;img/slide_02_640x340.jpg&quot;&gt;&lt;/div&gt;</div><div class="line">      &lt;div class=&quot;item&quot; data-image-lg=&quot;img/slide_03_2000x410.jpg&quot; data-image-xs=&quot;img/slide_03_640x340.jpg&quot;&gt;&lt;/div&gt;</div><div class="line">      &lt;div class=&quot;item&quot; data-image-lg=&quot;img/slide_04_2000x410.jpg&quot; data-image-xs=&quot;img/slide_04_640x340.jpg&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;!-- 控制按钮 --&gt;</div><div class="line">    &lt;a class=&quot;left carousel-control&quot; href=&quot;#main_ad&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt;</div><div class="line">      &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;</div><div class="line">      &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">    &lt;a class=&quot;right carousel-control&quot; href=&quot;#main_ad&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt;</div><div class="line">      &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;</div><div class="line">      &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">  &lt;/section&gt;</div></pre></td></tr></table></figure>
<p>4、css代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#main_ad .carousel-inner .item&#123;</div><div class="line">    background-size: cover; /*让图片覆盖满整个div*/</div><div class="line">    background-position: center,center; /*让图片在div里水平垂直居中*/</div><div class="line">    background-repeat: no-repeat;</div><div class="line">    height: 410px;</div><div class="line">&#125;</div><div class="line">@media (max-width:768px) &#123;</div><div class="line">    #main_ad .carousel-inner .item &#123;</div><div class="line">        height: auto;</div><div class="line">    &#125;</div><div class="line">    #main_ad .carousel-inner .item img&#123;</div><div class="line">        width: 100%;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5、js代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">$(function() &#123;</div><div class="line">  /**</div><div class="line">   * 根据屏幕宽度的变化决定轮播图片应该展示什么 5    */</div><div class="line">  function resize() &#123;</div><div class="line">    // 获取屏幕宽度</div><div class="line">    var windowWidth = $(window).width();</div><div class="line">    // 判断屏幕属于大还是小</div><div class="line">    var isSmallScreen = windowWidth &lt; 768;</div><div class="line">    // 根据大小为界面上的每一张轮播图设置背景</div><div class="line">    $(&apos;#main_ad &gt; .carousel-inner &gt; .item&apos;).each(function(i, item) &#123;</div><div class="line">      var $item = $(item);</div><div class="line">      // var imgSrc = $item.data(isSmallScreen ? &apos;image-xs&apos; : &apos;image-lg&apos;);</div><div class="line">      var imgSrc =</div><div class="line">        isSmallScreen ? $item.data(&apos;image-xs&apos;) : $item.data(&apos;image-lg&apos;);</div><div class="line">      // 设置背景图片</div><div class="line">      $item.css(&apos;backgroundImage&apos;, &apos;url(&quot;&apos; + imgSrc + &apos;&quot;)&apos;);</div><div class="line">      //</div><div class="line">      // 因为我们需要小图时 尺寸等比例变化，所以小图时我们使用img方式</div><div class="line">      if (isSmallScreen) &#123;</div><div class="line">        $item.html(&apos;&lt;img src=&quot;&apos; + imgSrc + &apos;&quot; alt=&quot;&quot; /&gt;&apos;);</div><div class="line">      &#125; else &#123;</div><div class="line">        $item.empty();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  // // 让window对象立即触发一下resize，初始化div的背景图</div><div class="line">  // $(window).trigger(&apos;resize&apos;);</div><div class="line"></div><div class="line"></div><div class="line">  $(window).on(&apos;resize&apos;, resize).trigger(&apos;resize&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<p>在移动端手指触摸轮播图切换效果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var carousels = $(&quot;.carousel&quot;);  //获取所有的轮播图</div><div class="line">    var startX,endX,finalMove;</div><div class="line">    var diviation = 60;  //让手指滑动一定距离轮播图才工作</div><div class="line">    carousels.on(&quot;touchstart&quot;,function(event) &#123;</div><div class="line">       // console.log(event.originalEvent.touches[0].pageX);</div><div class="line">        startX = event.originalEvent.touches[0].pageX;//获取手指接触屏幕时的位置</div><div class="line">    &#125;);</div><div class="line">    carousels.on(&quot;touchmove&quot;,function(event) &#123;</div><div class="line">       // console.log(event.originalEvent.touches[0].pageX);</div><div class="line">        endX = event.originalEvent.touches[0].pageX;//手指滑动时该值一直刷新，当手指离开时保留最后一次手指的位置</div><div class="line">    &#125;)</div><div class="line">    carousels.on(&quot;touchend&quot;,function(event) &#123;</div><div class="line">        //console.log(event.originalEvent.touches[0].pageX);</div><div class="line">        finalMove = Math.abs(startX - endX) - diviation;</div><div class="line">        if(finalMove &gt; 0 &amp;&amp; (startX - endX) &gt; 0) &#123;//如果手指滑动方向向左，轮播图向右播放一张图片</div><div class="line">            $(this).carousel(&apos;next);</div><div class="line">        &#125;</div><div class="line">        else if (finalMove &gt; 0 &amp;&amp; (startX - endX) &lt; 0) &#123;</div><div class="line">            $(this).carousel(&apos;prev&apos;);</div><div class="line">        &#125;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>一些补充：</p>
<p>　　1. 为什么不一开始就用img标签？</p>
<p>　　　 因为要让图片水平垂直居中，这样更方便</p>
<p>　　2.bootstrap文档地址：v3.bootcss.com</p>
<p>　　3.@media 可以针对不同的屏幕尺寸设置不同的样式</p>
<p>　　4.超小屏幕 手机 (&lt;768px) 小屏幕 平板 (≥768px)中等屏幕 桌 面显示器 (≥992px)大屏幕  大桌面显示器 (≥1200px)</p>
<p>原文地址：www.cnblogs.com/zmshare/p/6091102.html</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 自适应 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[收藏]js 字符串转换成数字的三种方法]]></title>
      <url>/2017/08/09/%E6%94%B6%E8%97%8F-js-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E5%AD%97%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在js读取文本框或者其它表单数据的时候获得的值是字符串类型的,例如两个文本框a和b,如果获得a的value值为11,b的value值为9 ,那么a.value要小于b.value,因为他们都是字符串形式的.在网上找了一下js字符串转数字的文章,这个比较全</p>
<p>方法主要有三种</p>
<p>转换函数、强制类型转换、利用js变量弱类型转换。</p>
<p>\1. 转换函数：</p>
<p>js提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是NaN(Not a Number)。</p>
<p>一些示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">parseInt(&quot;1234blue&quot;);   //returns   1234</div><div class="line">parseInt(&quot;0xA&quot;);   //returns   10</div><div class="line">parseInt(&quot;22.5&quot;);   //returns   22</div><div class="line">parseInt(&quot;blue&quot;);   //returns   NaN</div></pre></td></tr></table></figure>
<p>parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">parseInt(&quot;AF&quot;,   16);   //returns   175</div><div class="line">parseInt(&quot;10&quot;,   2);   //returns   2</div><div class="line">parseInt(&quot;10&quot;,   8);   //returns   8</div><div class="line">parseInt(&quot;10&quot;,   10);   //returns   10</div></pre></td></tr></table></figure>
<p>如果十进制数包含前导0，那么最好采用基数10，这样才不会意外地得到八进制的值。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">parseInt(&quot;010&quot;);   //returns   8</div><div class="line">parseInt(&quot;010&quot;,   8);   //returns   8</div><div class="line">parseInt(&quot;010&quot;,   10);   //returns   10</div></pre></td></tr></table></figure>
<p>parseFloat()方法与parseInt()方法的处理方式相似。<br>使用parseFloat()方法的另一不同之处在于，字符串必须以十进制形式表示浮点数，parseFloat()没有基模式。</p>
<p>下面是使用parseFloat()方法的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">parseFloat(&quot;1234blue&quot;);   //returns   1234.0</div><div class="line">parseFloat(&quot;0xA&quot;);   //returns   NaN</div><div class="line">parseFloat(&quot;22.5&quot;);   //returns   22.5</div><div class="line">parseFloat(&quot;22.34.5&quot;);   //returns   22.34</div><div class="line">parseFloat(&quot;0908&quot;);   //returns   908</div><div class="line">parseFloat(&quot;blue&quot;);   //returns   NaN</div></pre></td></tr></table></figure>
<p>\2. 强制类型转换</p>
<p>还可使用强制类型转换（type casting）处理转换值的类型。使用强制类型转换可以访问特定的值，即使它是另一种类型的。<br>ECMAScript中可用的3种强制类型转换如下：<br>Boolean(value)——把给定的值转换成Boolean型；<br>Number(value)——把给定的值转换成数字（可以是整数或浮点数）；<br>String(value)——把给定的值转换成字符串。<br>用这三个函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。这会造成意想不到的后果。<br>当要转换的值是至少有一个字符的字符串、非0数字或对象（下一节将讨论这一点）时，Boolean()函数将返回true。如果该值是空字符串、数字0、undefined或null，它将返回false。</p>
<p>可以用下面的代码段测试Boolean型的强制类型转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Boolean(&quot;&quot;);   //false   –   empty   string</div><div class="line">Boolean(&quot;hi&quot;);   //true   –   non-empty   string</div><div class="line">Boolean(100);   //true   –   non-zero   number</div><div class="line">Boolean(null);   //false   -   null</div><div class="line">Boolean(0);   //false   -   zero</div><div class="line">Boolean(new   Object());   //true   –   object</div></pre></td></tr></table></figure>
<p>Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">用　　法                   结　　果</div><div class="line">Number(false)                  0</div><div class="line">Number(true)                   1</div><div class="line">Number(undefined)              NaN</div><div class="line">Number(null)                   0</div><div class="line">Number( &quot;5.5 &quot;)                5.5</div><div class="line">Number( &quot;56 &quot;)                 56</div><div class="line">Number( &quot;5.6.7 &quot;)              NaN</div><div class="line">Number(new   Object())         NaN</div><div class="line">Number(100)                    100</div></pre></td></tr></table></figure>
<p>最后一种强制类型转换方法String()是最简单的，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var   s1   =   String(null);   //&quot;null&quot;</div><div class="line">var   oNull   =   null;</div><div class="line">var   s2   =   oNull.toString();   //won&apos;t   work,   causes   an   error</div></pre></td></tr></table></figure>
<p>\3. 利用js变量弱类型转换</p>
<p>举个小例子，一看，就会明白了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var   str= &apos;012.345 &apos;;</div><div class="line">var   x   =   str-0;</div><div class="line">x   =   x*1;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>上例利用了js的弱类型的特点，只进行了算术运算，实现了字符串到数字的类型转换，不过这个方法还是不推荐的</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 常见问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[收藏]阻止子元素的点击事件]]></title>
      <url>/2017/07/21/%E6%94%B6%E8%97%8F-%E9%98%BB%E6%AD%A2%E5%AD%90%E5%85%83%E7%B4%A0%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>问题描述：<br>今天在调试页面的时候遇到一个奇怪的现象，在一个父元素上面定义了一个点击事件，在父元素下面是一个一个的li标签，这上面没有任何点击事件。现象是当点击其中一个li标签时会发生一些动作。</p>
<p>这个问题困惑了我好久，我对代码翻了好几遍，最后才确定是，点击子元素时也将会触发父元素的事件。当时我把这种现象是在父元素上定义点击事件时，实际上是在这个区域中都定义了点击事件，所以当点击子元素时，实际上也是在点击父元素。</p>
<p>但是更科学的解释是：如果在点击子元素时，如果子元素中没有点击事件，那么该点击事件将自动冒泡到父元素，直到能找到一个可以处理点击事件的函数。</p>
<p>那这种解释可以带来的好处是，可以有方法来屏蔽这种现象，那就是阻止点击事件的冒泡。对于jQuery而言，就是stopPropagation().对于下面的代码而言，大家可以尝试下，如果没有stopPropagation和有stopPropagation之间的差别。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf8&quot;&gt;</div><div class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;</div><div class="line">&lt;script src=&quot;./jQuery/jquery-2.1.4.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    $(function() &#123;</div><div class="line">        $(&quot;#maindiv&quot;).click(function(event) &#123;</div><div class="line">            if($(this).children(&apos;ul&apos;).css(&quot;display&quot;) == &quot;none&quot;)</div><div class="line">                $(this).children(&apos;ul&apos;).css(&quot;display&quot;,&quot;block&quot;);</div><div class="line">            else</div><div class="line">                $(this).children(&apos;ul&apos;).css(&apos;display&apos;,&quot;none&quot;);</div><div class="line">        &#125;); </div><div class="line">        //阻止向上冒泡</div><div class="line">        $(&quot;#maindiv &gt; ul&quot;).click(function(event) &#123;</div><div class="line">            event.stopPropagation();</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;title&gt;测试如何屏蔽子元素的事件&lt;/title&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;maindiv&quot;&gt;</div><div class="line">        &lt;button&gt;click me&lt;/button&gt;</div><div class="line">        &lt;ul style=&quot;display:none&quot;&gt;</div><div class="line">            &lt;li&gt;first&lt;/li&gt;</div><div class="line">            &lt;li&gt;second&lt;/li&gt;</div><div class="line">            &lt;li&gt;third&lt;/li&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 元素点击事件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[收藏]jQuery移除或禁用html元素的点击事件]]></title>
      <url>/2017/07/21/%E6%94%B6%E8%97%8F-jQuery%E7%A7%BB%E9%99%A4%E6%88%96%E7%A6%81%E7%94%A8html%E5%85%83%E7%B4%A0%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>移除或禁用html元素的点击事件可以通过css实现也可以通过js或jQuery实现。</p>
<h3 id="一、CSS方法"><a href="#一、CSS方法" class="headerlink" title="一、CSS方法"></a>一、CSS方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.disabled &#123; pointer-events: none; &#125;</div></pre></td></tr></table></figure>
<h3 id="二、jQuery方法"><a href="#二、jQuery方法" class="headerlink" title="二、jQuery方法"></a>二、jQuery方法</h3><blockquote>
<p>方法一</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(this).click(function (event) &#123;  </div><div class="line">event.preventDefault();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>方法二</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(&apos;a&apos;).live(&apos;click&apos;, function(event) &#123;  </div><div class="line">       alert(&quot;抱歉,已停用！&quot;);    </div><div class="line">      event.preventDefault();     </div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>注：此方法中的live亦可以为on，bind等方法</p>
<blockquote>
<p>方法三</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;.disableCss&apos;).removeAttr(&apos;onclick&apos;);//去掉标签中的onclick事件</div></pre></td></tr></table></figure>
<p>通过removeAttr方法来控制html标签的属性已达到启用或禁用事件。另，使用这种方式也可以控制其他事件或其他效果。</p>
<blockquote>
<p>方法四</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(&apos;#button&apos;).attr(&apos;disabled&apos;,&quot;true&quot;);//添加disabled属性  </div><div class="line">$(&apos;#button&apos;).removeAttr(&quot;disabled&quot;); //移除disabled属性</div></pre></td></tr></table></figure>
<p>注：和方法三是一样的，不过disabled属性一般用在类型为button或submit的input上</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 屏蔽点击 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[收藏]java获取当天，前天，明天，本周，本月，本年的开始日期时间和结束日期时间]]></title>
      <url>/2017/07/20/%E6%94%B6%E8%97%8F-java%E8%8E%B7%E5%8F%96%E5%BD%93%E5%A4%A9%EF%BC%8C%E5%89%8D%E5%A4%A9%EF%BC%8C%E6%98%8E%E5%A4%A9%EF%BC%8C%E6%9C%AC%E5%91%A8%EF%BC%8C%E6%9C%AC%E6%9C%88%EF%BC%8C%E6%9C%AC%E5%B9%B4%E7%9A%84%E5%BC%80%E5%A7%8B%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E7%BB%93%E6%9D%9F%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div></pre></td><td class="code"><pre><div class="line">package demoone;</div><div class="line"></div><div class="line">import java.sql.Timestamp;</div><div class="line">import java.text.ParseException;</div><div class="line">import java.text.SimpleDateFormat;</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Calendar;</div><div class="line">import java.util.Date;</div><div class="line">import java.util.GregorianCalendar;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class DateUtils &#123;</div><div class="line">    //获取当天的开始时间</div><div class="line">    public static java.util.Date getDayBegin() &#123;</div><div class="line">        Calendar cal = new GregorianCalendar();</div><div class="line">        cal.set(Calendar.HOUR_OF_DAY, 0);</div><div class="line">        cal.set(Calendar.MINUTE, 0);</div><div class="line">        cal.set(Calendar.SECOND, 0);</div><div class="line">        cal.set(Calendar.MILLISECOND, 0);</div><div class="line">        return cal.getTime();</div><div class="line">    &#125;</div><div class="line">    //获取当天的结束时间</div><div class="line">    public static java.util.Date getDayEnd() &#123;</div><div class="line">        Calendar cal = new GregorianCalendar();</div><div class="line">        cal.set(Calendar.HOUR_OF_DAY, 23);</div><div class="line">        cal.set(Calendar.MINUTE, 59);</div><div class="line">        cal.set(Calendar.SECOND, 59);</div><div class="line">        return cal.getTime();</div><div class="line">    &#125;</div><div class="line">    //获取昨天的开始时间</div><div class="line">    public static Date getBeginDayOfYesterday() &#123;</div><div class="line">        Calendar cal = new GregorianCalendar();</div><div class="line">        cal.setTime(getDayBegin());</div><div class="line">        cal.add(Calendar.DAY_OF_MONTH, -1);</div><div class="line">        return cal.getTime();</div><div class="line">    &#125;</div><div class="line">    //获取昨天的结束时间</div><div class="line">    public static Date getEndDayOfYesterDay() &#123;</div><div class="line">        Calendar cal = new GregorianCalendar();</div><div class="line">        cal.setTime(getDayEnd());</div><div class="line">        cal.add(Calendar.DAY_OF_MONTH, -1);</div><div class="line">        return cal.getTime();</div><div class="line">    &#125;</div><div class="line">    //获取明天的开始时间</div><div class="line">    public static Date getBeginDayOfTomorrow() &#123;</div><div class="line">        Calendar cal = new GregorianCalendar();</div><div class="line">        cal.setTime(getDayBegin());</div><div class="line">        cal.add(Calendar.DAY_OF_MONTH, 1);</div><div class="line"></div><div class="line">        return cal.getTime();</div><div class="line">    &#125;</div><div class="line">    //获取明天的结束时间</div><div class="line">    public static Date getEndDayOfTomorrow() &#123;</div><div class="line">        Calendar cal = new GregorianCalendar();</div><div class="line">        cal.setTime(getDayEnd());</div><div class="line">        cal.add(Calendar.DAY_OF_MONTH, 1);</div><div class="line">        return cal.getTime();</div><div class="line">    &#125;</div><div class="line">    //获取本周的开始时间</div><div class="line">    public static Date getBeginDayOfWeek() &#123;</div><div class="line">        Date date = new Date();</div><div class="line">        if (date == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        Calendar cal = Calendar.getInstance();</div><div class="line">        cal.setTime(date);</div><div class="line">        int dayofweek = cal.get(Calendar.DAY_OF_WEEK);</div><div class="line">        if (dayofweek == 1) &#123;</div><div class="line">            dayofweek += 7;</div><div class="line">        &#125;</div><div class="line">        cal.add(Calendar.DATE, 2 - dayofweek);</div><div class="line">        return getDayStartTime(cal.getTime());</div><div class="line">    &#125;</div><div class="line">    //获取本周的结束时间</div><div class="line">    public static Date getEndDayOfWeek()&#123;</div><div class="line">        Calendar cal = Calendar.getInstance();</div><div class="line">        cal.setTime(getBeginDayOfWeek());  </div><div class="line">        cal.add(Calendar.DAY_OF_WEEK, 6); </div><div class="line">        Date weekEndSta = cal.getTime();</div><div class="line">        return getDayEndTime(weekEndSta);</div><div class="line">    &#125;</div><div class="line">    //获取本月的开始时间</div><div class="line">     public static Date getBeginDayOfMonth() &#123;</div><div class="line">            Calendar calendar = Calendar.getInstance();</div><div class="line">            calendar.set(getNowYear(), getNowMonth() - 1, 1);</div><div class="line">            return getDayStartTime(calendar.getTime());</div><div class="line">        &#125;</div><div class="line">    //获取本月的结束时间</div><div class="line">     public static Date getEndDayOfMonth() &#123;</div><div class="line">            Calendar calendar = Calendar.getInstance();</div><div class="line">            calendar.set(getNowYear(), getNowMonth() - 1, 1);</div><div class="line">            int day = calendar.getActualMaximum(5);</div><div class="line">            calendar.set(getNowYear(), getNowMonth() - 1, day);</div><div class="line">            return getDayEndTime(calendar.getTime());</div><div class="line">        &#125;</div><div class="line">     //获取本年的开始时间</div><div class="line">     public static java.util.Date getBeginDayOfYear() &#123;</div><div class="line">            Calendar cal = Calendar.getInstance();</div><div class="line">            cal.set(Calendar.YEAR, getNowYear());</div><div class="line">            // cal.set</div><div class="line">            cal.set(Calendar.MONTH, Calendar.JANUARY);</div><div class="line">            cal.set(Calendar.DATE, 1);</div><div class="line"></div><div class="line">            return getDayStartTime(cal.getTime());</div><div class="line">        &#125;</div><div class="line">     //获取本年的结束时间</div><div class="line">     public static java.util.Date getEndDayOfYear() &#123;</div><div class="line">            Calendar cal = Calendar.getInstance();</div><div class="line">            cal.set(Calendar.YEAR, getNowYear());</div><div class="line">            cal.set(Calendar.MONTH, Calendar.DECEMBER);</div><div class="line">            cal.set(Calendar.DATE, 31);</div><div class="line">            return getDayEndTime(cal.getTime());</div><div class="line">        &#125;</div><div class="line">    //获取某个日期的开始时间</div><div class="line">    public static Timestamp getDayStartTime(Date d) &#123;</div><div class="line">        Calendar calendar = Calendar.getInstance();</div><div class="line">        if(null != d) calendar.setTime(d);</div><div class="line">        calendar.set(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),    calendar.get(Calendar.DAY_OF_MONTH), 0, 0, 0);</div><div class="line">        calendar.set(Calendar.MILLISECOND, 0);</div><div class="line">        return new Timestamp(calendar.getTimeInMillis());</div><div class="line">    &#125;</div><div class="line">    //获取某个日期的结束时间</div><div class="line">    public static Timestamp getDayEndTime(Date d) &#123;</div><div class="line">        Calendar calendar = Calendar.getInstance();</div><div class="line">        if(null != d) calendar.setTime(d);</div><div class="line">        calendar.set(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH),    calendar.get(Calendar.DAY_OF_MONTH), 23, 59, 59);</div><div class="line">        calendar.set(Calendar.MILLISECOND, 999);</div><div class="line">        return new Timestamp(calendar.getTimeInMillis());</div><div class="line">    &#125;</div><div class="line">    //获取今年是哪一年</div><div class="line">     public static Integer getNowYear() &#123;</div><div class="line">             Date date = new Date();</div><div class="line">            GregorianCalendar gc = (GregorianCalendar) Calendar.getInstance();</div><div class="line">            gc.setTime(date);</div><div class="line">            return Integer.valueOf(gc.get(1));</div><div class="line">        &#125;</div><div class="line">     //获取本月是哪一月</div><div class="line">     public static int getNowMonth() &#123;</div><div class="line">             Date date = new Date();</div><div class="line">            GregorianCalendar gc = (GregorianCalendar) Calendar.getInstance();</div><div class="line">            gc.setTime(date);</div><div class="line">            return gc.get(2) + 1;</div><div class="line">        &#125;</div><div class="line">     //两个日期相减得到的天数</div><div class="line">     public static int getDiffDays(Date beginDate, Date endDate) &#123;</div><div class="line"></div><div class="line">            if (beginDate == null || endDate == null) &#123;</div><div class="line">                throw new IllegalArgumentException(&quot;getDiffDays param is null!&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            long diff = (endDate.getTime() - beginDate.getTime())</div><div class="line">                    / (1000 * 60 * 60 * 24);</div><div class="line"></div><div class="line">            int days = new Long(diff).intValue();</div><div class="line"></div><div class="line">            return days;</div><div class="line">        &#125;</div><div class="line">    //两个日期相减得到的毫秒数</div><div class="line">     public static long dateDiff(Date beginDate, Date endDate) &#123;</div><div class="line">            long date1ms = beginDate.getTime();</div><div class="line">            long date2ms = endDate.getTime();</div><div class="line">            return date2ms - date1ms;</div><div class="line">        &#125;</div><div class="line">     //获取两个日期中的最大日期</div><div class="line">     public static Date max(Date beginDate, Date endDate) &#123;</div><div class="line">            if (beginDate == null) &#123;</div><div class="line">                return endDate;</div><div class="line">            &#125;</div><div class="line">            if (endDate == null) &#123;</div><div class="line">                return beginDate;</div><div class="line">            &#125;</div><div class="line">            if (beginDate.after(endDate)) &#123;</div><div class="line">                return beginDate;</div><div class="line">            &#125;</div><div class="line">            return endDate;</div><div class="line">        &#125;</div><div class="line">     //获取两个日期中的最小日期</div><div class="line">     public static Date min(Date beginDate, Date endDate) &#123;</div><div class="line">            if (beginDate == null) &#123;</div><div class="line">                return endDate;</div><div class="line">            &#125;</div><div class="line">            if (endDate == null) &#123;</div><div class="line">                return beginDate;</div><div class="line">            &#125;</div><div class="line">            if (beginDate.after(endDate)) &#123;</div><div class="line">                return endDate;</div><div class="line">            &#125;</div><div class="line">            return beginDate;</div><div class="line">        &#125;</div><div class="line">     //返回某月该季度的第一个月</div><div class="line">     public static Date getFirstSeasonDate(Date date) &#123;</div><div class="line">             final int[] SEASON = &#123; 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4 &#125;;</div><div class="line">            Calendar cal = Calendar.getInstance();</div><div class="line">            cal.setTime(date);</div><div class="line">            int sean = SEASON[cal.get(Calendar.MONTH)];</div><div class="line">            cal.set(Calendar.MONTH, sean * 3 - 3);</div><div class="line">            return cal.getTime();</div><div class="line">        &#125;</div><div class="line">     //返回某个日期下几天的日期</div><div class="line">     public static Date getNextDay(Date date, int i) &#123;</div><div class="line">            Calendar cal = new GregorianCalendar();</div><div class="line">            cal.setTime(date);</div><div class="line">            cal.set(Calendar.DATE, cal.get(Calendar.DATE) + i);</div><div class="line">            return cal.getTime();</div><div class="line">        &#125;</div><div class="line">     //返回某个日期前几天的日期</div><div class="line">     public static Date getFrontDay(Date date, int i) &#123;</div><div class="line">            Calendar cal = new GregorianCalendar();</div><div class="line">            cal.setTime(date);</div><div class="line">            cal.set(Calendar.DATE, cal.get(Calendar.DATE) - i);</div><div class="line">            return cal.getTime();</div><div class="line">        &#125;</div><div class="line">     //获取某年某月到某年某月按天的切片日期集合（间隔天数的日期集合）</div><div class="line">     public static List getTimeList(int beginYear, int beginMonth, int endYear,</div><div class="line">                int endMonth, int k) &#123;</div><div class="line">            List list = new ArrayList();</div><div class="line">            if (beginYear == endYear) &#123;</div><div class="line">                for (int j = beginMonth; j &lt;= endMonth; j++) &#123;</div><div class="line">                    list.add(getTimeList(beginYear, j, k));</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                &#123;</div><div class="line">                    for (int j = beginMonth; j &lt; 12; j++) &#123;</div><div class="line">                        list.add(getTimeList(beginYear, j, k));</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    for (int i = beginYear + 1; i &lt; endYear; i++) &#123;</div><div class="line">                        for (int j = 0; j &lt; 12; j++) &#123;</div><div class="line">                            list.add(getTimeList(i, j, k));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    for (int j = 0; j &lt;= endMonth; j++) &#123;</div><div class="line">                        list.add(getTimeList(endYear, j, k));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">     //获取某年某月按天切片日期集合（某个月间隔多少天的日期集合）</div><div class="line">     public static List getTimeList(int beginYear, int beginMonth, int k) &#123;</div><div class="line">            List list = new ArrayList();</div><div class="line">            Calendar begincal = new GregorianCalendar(beginYear, beginMonth, 1);</div><div class="line">            int max = begincal.getActualMaximum(Calendar.DATE);</div><div class="line">            for (int i = 1; i &lt; max; i = i + k) &#123;</div><div class="line">                list.add(begincal.getTime());</div><div class="line">                begincal.add(Calendar.DATE, k);</div><div class="line">            &#125;</div><div class="line">            begincal = new GregorianCalendar(beginYear, beginMonth, max);</div><div class="line">            list.add(begincal.getTime());</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//获取某年某月的第一天日期</div><div class="line"> public static Date getStartMonthDate(int year, int month) &#123;</div><div class="line">        Calendar calendar = Calendar.getInstance();</div><div class="line">        calendar.set(year, month - 1, 1);</div><div class="line">        return calendar.getTime();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//获取某年某月的最后一天日期</div><div class="line">   public static Date getEndMonthDate(int year, int month) &#123;</div><div class="line">        Calendar calendar = Calendar.getInstance();</div><div class="line">        calendar.set(year, month - 1, 1);</div><div class="line">        int day = calendar.getActualMaximum(5);</div><div class="line">        calendar.set(year, month - 1, day);</div><div class="line">        return calendar.getTime();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 后端语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
            <tag> 时间获取，获取当前时间 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[收藏]JS中常见问题]]></title>
      <url>/2017/07/14/%E6%94%B6%E8%97%8F-JS%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//s金额   n保留几位小数 默认保留两位小数 s代表金额，n代表保留的小数位数</div><div class="line">function formatMoney(s, n) &#123;</div><div class="line">            n = n &gt; 0 &amp;&amp; n &lt;= 20 ? n : 2;</div><div class="line">            s = parseFloat((s + &quot;&quot;).replace(/[^\d\.-]/g, &quot;&quot;)).toFixed(n) + &quot;&quot;;</div><div class="line">            var l = s.split(&quot;.&quot;)[0].split(&quot;&quot;).reverse(), r = s.split(&quot;.&quot;)[1];</div><div class="line">            t = &quot;&quot;;</div><div class="line">            for (i = 0; i &lt; l.length; i++) &#123;</div><div class="line">                t += l[i] + ((i + 1) % 3 == 0 &amp;&amp; (i + 1) != l.length ? &quot;,&quot; : &quot;&quot;);</div><div class="line">            &#125;</div><div class="line">            return t.split(&quot;&quot;).reverse().join(&quot;&quot;) + &quot;.&quot; + r;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//小数点往后移动两位[实际上是*100,但是例如:1.0011*100在JS中结果不对。]</div><div class="line">function numberChange(i)&#123;</div><div class="line">    if(i==0)&#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    var str = i.toString(),len = 0,arr=[],newStr=&apos;&apos;;</div><div class="line">    for(var i = 0;i&lt;str.length;i++)&#123;</div><div class="line">        if(str[i]==&apos;.&apos;)&#123;</div><div class="line">            len = i;</div><div class="line">        &#125;</div><div class="line">        arr.push(str[i])</div><div class="line">    &#125;</div><div class="line">    arr[len] = arr[len+1];</div><div class="line">    arr[len+1] = arr[len+2];</div><div class="line">    arr[len+2] = &apos;.&apos;;</div><div class="line">    for(var i = 0;i&lt;arr.length;i++)&#123;</div><div class="line">        newStr+=arr[i];</div><div class="line">    &#125;</div><div class="line">    return Number(newStr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//1。获得屏幕的分辨率： </div><div class="line">screen.width </div><div class="line">screen.height </div><div class="line"></div><div class="line">//2。获得窗口大小： </div><div class="line">document.body.clientWidth </div><div class="line">document.body.clientHeight </div><div class="line"></div><div class="line">//3。获得窗口大小（包含Border、Scroll等元素） </div><div class="line">document.body.offsetWidth </div><div class="line">document.body.offsetHeight  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">document.documentElement.clientHeight  //获取当前浏览器窗口可工作高度</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//鼠标相对于网页的坐标</div><div class="line">function mousePos(e)&#123;</div><div class="line">     var x,y;</div><div class="line">     var e = e||window.event;</div><div class="line">     return &#123;</div><div class="line">          x:e.clientX+document.body.scrollLeft+document.documentElement.scrollLeft,</div><div class="line">          y:e.clientY+document.body.scrollTop+document.documentElement.scrollTop</div><div class="line">     &#125;;</div><div class="line">&#125;;</div><div class="line">~function (e)&#123;</div><div class="line">     var e = e||window.event;</div><div class="line">     alert(‘X:&apos;+mousePos(e).x+’|||Y:&apos;+mousePos(e).y);</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p>js 中的奇葩问题</p>
<p>1、eg：000101 = 65; </p>
<p>000101为获取到的字符串类型，通过click事件传递，000101变为了65;</p>
<p>解决方法：jq中直接运行的代码中获取到的000101为字符串类型，但是后边人为运行此代码相关的代码时获取到的000101就为number类型。由此可见在JS中数字前面加0代表此数字为八进制。可以将000101作为属性传递，或者将000101通过代码直接执行时获取到的是字符串的机制来经行判断转换然后再传递，从而在事件中再去获取判断。</p>
<p>2、执行函数以及引用函数同时出现；</p>
<p>eg：fun(successCallBack(data),failCallBack);successCallBack和failCallBack都是函数，调用fun函数返回成功时，必然走成功，没有问题，但是返回失败时，必走成功，失败同时也会掉，2个同时执行，所以调用un函数时success 和 fail 应该都为执行函数或者引用函数，这样就不会出现返回失败走成功回调的情况。</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 常见问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[收藏]遍历Map的四种方法]]></title>
      <url>/2017/07/13/%E6%94%B6%E8%97%8F-%E9%81%8D%E5%8E%86Map%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line"></div><div class="line"></div><div class="line">  Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</div><div class="line">  map.put(&quot;1&quot;, &quot;value1&quot;);</div><div class="line">  map.put(&quot;2&quot;, &quot;value2&quot;);</div><div class="line">  map.put(&quot;3&quot;, &quot;value3&quot;);</div><div class="line">  </div><div class="line">  //第一种：普遍使用，二次取值</div><div class="line">  System.out.println(&quot;通过Map.keySet遍历key和value：&quot;);</div><div class="line">  for (String key : map.keySet()) &#123;</div><div class="line">   System.out.println(&quot;key= &quot;+ key + &quot; and value= &quot; + map.get(key));</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  //第二种</div><div class="line">  System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;);</div><div class="line">  Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</div><div class="line">  while (it.hasNext()) &#123;</div><div class="line">   Map.Entry&lt;String, String&gt; entry = it.next();</div><div class="line">   System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue());</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  //第三种：推荐，尤其是容量大时</div><div class="line">  System.out.println(&quot;通过Map.entrySet遍历key和value&quot;);</div><div class="line">  for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</div><div class="line">   System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //第四种</div><div class="line">  System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;);</div><div class="line">  for (String v : map.values()) &#123;</div><div class="line">   System.out.println(&quot;value= &quot; + v);</div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 后端语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> map遍历 </tag>
            
            <tag> 遍历 </tag>
            
            <tag> 后端语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[收藏]悟透JavaScript（理解JS面向对象的好文章）]]></title>
      <url>/2017/07/13/%E6%94%B6%E8%97%8F-%E6%82%9F%E9%80%8FJavaScript%EF%BC%88%E7%90%86%E8%A7%A3JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%BD%E6%96%87%E7%AB%A0%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><hr>
<p>​    编程世界里只存在两种基本元素，一个是数据，一个是代码。编程世界就是在数据和代码千丝万缕的纠缠中呈现出无限的生机和活力。<br>​    数据天生就是文静的，总想保持自己固有的本色；而代码却天生活泼，总想改变这个世界。<br>   你看，数据代码间的关系与物质能量间的关系有着惊人的相似。数据也是有惯性的，如果没有代码来施加外力，她总保持自己原来的状态。而代码就象能量，他存在 的唯一目的，就是要努力改变数据原来的状态。在代码改变数据的同时，也会因为数据的抗拒而反过来影响或改变代码原有的趋势。甚至在某些情况下，数据可以转 变为代码，而代码却又有可能被转变为数据，或许还存在一个类似E=MC2形式的数码转换方程呢。然而，就是在数据和代码间这种即矛盾又统一的运转中，总能 体现出计算机世界的规律，这些规律正是我们编写的程序逻辑。<br>​    不过，由于不同程序员有着不同的世界观，这些数据和代码看起来也就不尽相同。于是，不同世界观的程序员们运用各自的方法论，推动着编程世界的进化和发展。<br>​    众所周知，当今最流行的编程思想莫过于面向对象编程的思想。为什么面向对象的思想能迅速风靡编程世界呢？因为面向对象的思想首次把数据和代码结合成统一 体，并以一个简单的对象概念呈现给编程者。这一下子就将原来那些杂乱的算法与子程序，以及纠缠不清的复杂数据结构，划分成清晰而有序的对象结构，从而理清 了数据与代码在我们心中那团乱麻般的结。我们又可以有一个更清晰的思维，在另一个思想高度上去探索更加浩瀚的编程世界了。<br>​    在五祖弘忍讲授完《对象真经》之后的一天，他对众弟子们说：“经已讲完，想必尔等应该有所感悟，请各自写个偈子来看”。大弟子神秀是被大家公认为悟性最高 的师兄，他的偈子写道：“身是对象树，心如类般明。朝朝勤拂拭，莫让惹尘埃！”。此偈一出，立即引起师兄弟们的轰动，大家都说写得太好了。只有火头僧慧能 看后，轻轻地叹了口气，又随手在墙上写道：“对象本无根，类型亦无形。本来无一物，何处惹尘埃？”。然后摇了摇头，扬长而去。大家看了慧能的偈子都说： “写的什么乱七八糟的啊，看不懂”。师父弘忍看了神秀的诗偈也点头称赞，再看慧能的诗偈之后默然摇头。就在当天夜里，弘忍却悄悄把慧能叫到自己的禅房，将 珍藏多年的软件真经传授于他，然后让他趁着月色连夜逃走…<br>​    后来，慧能果然不负师父厚望，在南方开创了禅宗另一个广阔的天空。而慧能当年带走的软件真经中就有一本是《JavaScript真经》！</p>
<h3 id="回归简单"><a href="#回归简单" class="headerlink" title="回归简单"></a>回归简单</h3><hr>
<p>​    要理解JavaScript，你得首先放下对象和类的概念，回到数据和代码的本原。前面说过，编程世界只有数据和代码两种基本元素，而这两种元素又有着纠缠不清的关系。JavaScript就是把数据和代码都简化到最原始的程度。<br>​    JavaScript中的数据很简洁的。简单数据只有 undefined, null, boolean, number和string这五种，而复杂数据只有一种，即object。这就好比中国古典的朴素唯物思想，把世界最基本的元素归为金木水火土，其他复杂 的物质都是由这五种基本元素组成。<br>​    JavaScript中的代码只体现为一种形式，就是function。<br>​    注意：以上单词都是小写的，不要和Number, String, Object, Function等JavaScript内置函数混淆了。要知道，JavaScript语言是区分大小写的呀!<br>​    任何一个JavaScript的标识、常量、变量和参数都只是unfined, null, bool, number, string, object 和 function类型中的一种，也就typeof返回值表明的类型。除此之外没有其他类型了。<br>​    先说说简单数据类型吧。<br>​    undefined:   代表一切未知的事物，啥都没有，无法想象，代码也就更无法去处理了。<br>​                      注意：typeof(undefined) 返回也是 undefined。<br>​                              可以将undefined赋值给任何变量或属性，但并不意味了清除了该变量，反而会因此多了一个属性。<br>​    null:            有那么一个概念，但没有东西。无中似有，有中还无。虽难以想象，但已经可以用代码来处理了。<br>​                      注意：typeof(null)返回object，但null并非object，具有null值的变量也并非object。<br>​    boolean:      是就是，非就非，没有疑义。对就对，错就错，绝对明确。既能被代码处理，也可以控制代码的流程。<br>​    number:      线性的事物，大小和次序分明，多而不乱。便于代码进行批量处理，也控制代码的迭代和循环等。<br>​                      注意：typeof(NaN)和typeof(Infinity)都返回number 。<br>​                              NaN参与任何数值计算的结构都是NaN，而且 NaN != NaN 。<br>​                              Infinity / Infinity = NaN 。<br>​    string:         面向人类的理性事物，而不是机器信号。人机信息沟通，代码据此理解人的意图等等，都靠它了。<br>​     简单类型都不是对象，JavaScript没有将对象化的能力赋予这些简单类型。直接被赋予简单类型常量值的标识符、变量和参数都不是一个对象。<br>​    所谓“对象化”，就是可以将数据和代码组织成复杂结构的能力。JavaScript中只有object类型和function类型提供了对象化的能力。</p>
<h3 id="没有类"><a href="#没有类" class="headerlink" title="没有类"></a>没有类</h3><hr>
<p>​    object就是对象的类型。在JavaScript中不管多么复杂的数据和代码，都可以组织成object形式的对象。<br>​    但JavaScript却没有 “类”的概念！<br>​    对于许多面向对象的程序员来说，这恐怕是JavaScript中最难以理解的地方。是啊，几乎任何讲面向对象的书中，第一个要讲的就是“类”的概 念，这可是面向对象的支柱。这突然没有了“类”，我们就象一下子没了精神支柱，感到六神无主。看来，要放下对象和类，达到“对象本无根，类型亦无形”的境 界确实是件不容易的事情啊。<br>​    这样，我们先来看一段JavaScript程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">var life = &#123;&#125;;</div><div class="line"></div><div class="line">for(life.age = 1; life.age &lt;= 3; life.age++)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    switch(life.age)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        case 1: life.body = &quot;卵细胞&quot;;</div><div class="line"></div><div class="line">                life.say = function()&#123;alert(this.age+this.body)&#125;;</div><div class="line"></div><div class="line">                break;</div><div class="line"></div><div class="line">        case 2: life.tail = &quot;尾巴&quot;;</div><div class="line"></div><div class="line">                life.gill = &quot;腮&quot;;</div><div class="line"></div><div class="line">                life.body = &quot;蝌蚪&quot;;</div><div class="line"></div><div class="line">                life.say = function()&#123;alert(this.age+this.body+&quot;-&quot;+this.tail+&quot;,&quot;+this.gill)&#125;;</div><div class="line"></div><div class="line">                break;</div><div class="line"></div><div class="line">        case 3: delete life.tail;</div><div class="line"></div><div class="line">                delete life.gill;</div><div class="line"></div><div class="line">                life.legs = &quot;四条腿&quot;;</div><div class="line"></div><div class="line">                life.lung = &quot;肺&quot;;</div><div class="line"></div><div class="line">                life.body = &quot;青蛙&quot;;</div><div class="line"></div><div class="line">                life.say = function()&#123;alert(this.age+this.body+&quot;-&quot;+this.legs+&quot;,&quot;+this.lung)&#125;;</div><div class="line"></div><div class="line">                break;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    life.say();</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>​    这段JavaScript程序一开始产生了一个生命对象life，life诞生时只是一个光溜溜的对象，没有任何属性和方法。在第一次生命过程中，它有了 一个身体属性body，并有了一个say方法，看起来是一个“卵细胞”。在第二次生命过程中，它又长出了“尾巴”和“腮”，有了tail和gill属性， 显然它是一个“蝌蚪”。在第三次生命过程中，它的tail和gill属性消失了，但又长出了“四条腿”和“肺”，有了legs和lung属性，从而最终变 成了“青蛙”。如果，你的想像力丰富的话，或许还能让它变成英俊的“王子”，娶个美丽的“公主”什么的。不过，在看完这段程序之后，请你思考一个问题：<br>​    我们一定需要类吗？<br>​    还记得儿时那个“小蝌蚪找妈妈”的童话吗？也许就在昨天晚，你的孩子刚好是在这个美丽的童话中进入梦乡的吧。可爱的小蝌蚪也就是在其自身类型不断演化过程 中，逐渐变成了和妈妈一样的“类”，从而找到了自己的妈妈。这个童话故事中蕴含的编程哲理就是：对象的“类”是从无到有，又不断演化，最终又消失于无形之 中的…<br>​    “类”，的确可以帮助我们理解复杂的现实世界，这纷乱的现实世界也的确需要进行分类。但如果我们的思想被“类”束缚住了，“类”也就变成了“累”。想象一 下，如果一个生命对象开始的时就被规定了固定的“类”，那么它还能演化吗？蝌蚪还能变成青蛙吗？还可以给孩子们讲小蝌蚪找妈妈的故事吗？<br>​    所以，JavaScript中没有“类”，类已化于无形，与对象融为一体。正是由于放下了“类”这个概念，JavaScript的对象才有了其他编程语言所没有的活力。<br>​    如果，此时你的内心深处开始有所感悟，那么你已经逐渐开始理解JavaScript的禅机了。</p>
<h3 id="函数的魔力"><a href="#函数的魔力" class="headerlink" title="函数的魔力"></a>函数的魔力</h3><hr>
<p>​        接下来，我们再讨论一下JavaScript函数的魔力吧。<br>​    JavaScript的代码就只有function一种形式，function就是函数的类型。也许其他编程语言还有procedure或 method等代码概念，但在JavaScript里只有function一种形式。当我们写下一个函数的时候，只不过是建立了一个function类型 的实体而已。请看下面的程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function myfunc()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;hello&quot;);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    alert(typeof(myfunc));</div></pre></td></tr></table></figure>
<p>​    这个代码运行之后可以看到typeof(myfunc)返回的是function。以上的函数写法我们称之为“定义式”的，如果我们将其改写成下面的“变量式”的，就更容易理解了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var myfunc = function ()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;hello&quot;);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">alert(typeof(myfunc));</div></pre></td></tr></table></figure>
<p>​    这里明确定义了一个变量myfunc，它的初始值被赋予了一个function的实体。因此，typeof(myfunc)返回的也是function。 其实，这两种函数的写法是等价的，除了一点细微差别，其内部实现完全相同。也就是说，我们写的这些JavaScript函数只是一个命了名的变量而已，其 变量类型即为function，变量的值就是我们编写的函数代码体。<br>​    聪明的你或许立即会进一步的追问：既然函数只是变量，那么变量就可以被随意赋值并用到任意地方啰？<br>​    我们来看看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var myfunc = function ()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;hello&quot;);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">myfunc(); //第一次调用myfunc，输出hello</div><div class="line"></div><div class="line">myfunc = function ()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;yeah&quot;);</div><div class="line"></div><div class="line">    &#125;;    </div><div class="line"></div><div class="line">myfunc(); //第二次调用myfunc，将输出yeah</div></pre></td></tr></table></figure>
<p>​    这个程序运行的结果告诉我们：答案是肯定的！在第一次调用函数之后，函数变量又被赋予了新的函数代码体，使得第二次调用该函数时，出现了不同的输出。<br>​    好了，我们又来把上面的代码改成第一种定义式的函数形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function myfunc ()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    alert(&quot;hello&quot;);</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">myfunc(); //这里调用myfunc，输出yeah而不是hello</div><div class="line"></div><div class="line">function myfunc ()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    alert(&quot;yeah&quot;);</div><div class="line"></div><div class="line">&#125;;    </div><div class="line"></div><div class="line">myfunc(); //这里调用myfunc，当然输出yeah</div></pre></td></tr></table></figure>
<p>​    按理说，两个签名完全相同的函数，在其他编程语言中应该是非法的。但在JavaScript中，这没错。不过，程序运行之后却发现一个奇怪的现象：两次调用都只是最后那个函数里输出的值！显然第一个函数没有起到任何作用。这又是为什么呢？<br>​    原来，JavaScript执行引擎并非一行一行地分析和执行程序，而是一段一段地分析执行的。而且，在同一段程序的分析执行中，定义式的函数语句会被提 取出来优先执行。函数定义执行完之后，才会按顺序执行其他语句代码。也就是说，在第一次调用myfunc之前，第一个函数语句定义的代码逻辑，已被第二个 函数定义语句覆盖了。所以，两次都调用都是执行最后一个函数逻辑了。<br>​    如果把这个JavaScript代码分成两段，例如将它们写在一个html中，并用script标签将其分成这样的两块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"></div><div class="line">    function myfunc ()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;hello&quot;);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    myfunc(); //这里调用myfunc，输出hello</div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line"></div><div class="line">    function myfunc ()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;yeah&quot;);</div><div class="line"></div><div class="line">    &#125;;    </div><div class="line"></div><div class="line">    myfunc(); //这里调用myfunc，输出yeah</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>​    这时，输出才是各自按顺序来的，也证明了JavaScript的确是一段段地执行的。<br>​    一段代码中的定义式函数语句会优先执行，这似乎有点象静态语言的编译概念。所以，这一特征也被有些人称为：JavaScript的“预编译”。<br>​    大多数情况下，我们也没有必要去纠缠这些细节问题。只要你记住一点：JavaScript里的代码也是一种数据，同样可以被任意赋值和修改的，而它的值就是代码的逻辑。只是，与一般数据不同的是，函数是可以被调用执行的。<br>​    不过，如果JavaScript函数仅仅只有这点道行的话，这与C++的函数指针，DELPHI的方法指针，C#的委托相比，又有啥稀奇嘛！然 而，JavaScript函数的神奇之处还体现在另外两个方面：一是函数function类型本身也具有对象化的能力，二是函数function与对象 object超然的结合能力。</p>
<h3 id="奇妙的对象"><a href="#奇妙的对象" class="headerlink" title="奇妙的对象"></a>奇妙的对象</h3><hr>
<p>​    先来说说函数的对象化能力。</p>
<p>​    任何一个函数都可以为其动态地添加或去除属性，这些属性可以是简单类型，可以是对象，也可以是其他函数。也就是说，函数具有对象的全部特征，你完全可以把 函数当对象来用。其实，函数就是对象，只不过比一般的对象多了一个括号“()”操作符，这个操作符用来执行函数的逻辑。即，函数本身还可以被调用，一般对 象却不可以被调用，除此之外完全相同。请看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Sing()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    with(arguments.callee)</div><div class="line"></div><div class="line">      alert(author + &quot;：&quot; + poem);</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">Sing.author = &quot;李白&quot;;</div><div class="line"></div><div class="line">Sing.poem = &quot;汉家秦地月，流影照明妃。一上玉关道，天涯去不归&quot;;</div><div class="line"></div><div class="line">Sing();</div><div class="line"></div><div class="line">Sing.author = &quot;李战&quot;;</div><div class="line"></div><div class="line">Sing.poem = &quot;日出汉家天，月落阴山前。女儿琵琶怨，已唱三千年&quot;;</div><div class="line"></div><div class="line">Sing();</div></pre></td></tr></table></figure>
<p>​    在这段代码中，Sing函数被定义后，又给Sing函数动态地增加了author和poem属性。将author和poem属性设为不同的作者和诗句，在 调用Sing()时就能显示出不同的结果。这个示例用一种诗情画意的方式，让我们理解了JavaScript函数就是对象的本质，也感受到了 JavaScript语言的优美。<br>​    好了，以上的讲述，我们应该算理解了function类型的东西都是和object类型一样的东西，这种东西被我们称为“对象”。我们的确可以这样去看待这些“对象”，因为它们既有“属性”也有“方法”嘛。但下面的代码又会让我们产生新的疑惑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var anObject = &#123;&#125;;  //一个对象</div><div class="line"></div><div class="line">anObject.aProperty = &quot;Property of object&quot;;  //对象的一个属性</div><div class="line"></div><div class="line">anObject.aMethod = function()&#123;alert(&quot;Method of object&quot;)&#125;; //对象的一个方法</div><div class="line"></div><div class="line">//主要看下面：</div><div class="line"></div><div class="line">alert(anObject[&quot;aProperty&quot;]);   //可以将对象当数组以属性名作为下标来访问属性</div><div class="line"></div><div class="line">anObject&quot;aMethod&quot;;          //可以将对象当数组以方法名作为下标来调用方法</div><div class="line"></div><div class="line">for( var s in anObject)           //遍历对象的所有属性和方法进行迭代化处理</div><div class="line"></div><div class="line">    alert(s + &quot; is a &quot; + typeof(anObject[s]));</div></pre></td></tr></table></figure>
<p>​    同样对于function类型的对象也是一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var aFunction = function() &#123;&#125;;  //一个函数</div><div class="line"></div><div class="line">aFunction.aProperty = &quot;Property of function&quot;;  //函数的一个属性</div><div class="line"></div><div class="line">aFunction.aMethod = function()&#123;alert(&quot;Method of function&quot;)&#125;; //函数的一个方法</div><div class="line"></div><div class="line">//主要看下面：</div><div class="line"></div><div class="line">alert(aFunction[&quot;aProperty&quot;]);   //可以将函数当数组以属性名作为下标来访问属性</div><div class="line"></div><div class="line">aFunction&quot;aMethod&quot;;          //可以将函数当数组以方法名作为下标来调用方法</div><div class="line"></div><div class="line">for( var s in aFunction)           //遍历函数的所有属性和方法进行迭代化处理</div><div class="line"></div><div class="line">    alert(s + &quot; is a &quot; + typeof(aFunction[s]));</div></pre></td></tr></table></figure>
<p>​    是的，对象和函数可以象数组一样，用属性名或方法名作为下标来访问并处理。那么，它到底应该算是数组呢，还是算对象？<br>​    我们知道，数组应该算是线性数据结构，线性数据结构一般有一定的规律，适合进行统一的批量迭代操作等，有点像波。而对象是离散数据结构，适合描述分散的和个性化的东西，有点像粒子。因此，我们也可以这样问：JavaScript里的对象到底是波还是粒子？<br>​    如果存在对象量子论，那么答案一定是：波粒二象性！<br>​    因此，JavaScript里的函数和对象既有对象的特征也有数组的特征。这里的数组被称为“字典”，一种可以任意伸缩的名称值对儿的集合。其实， object和function的内部实现就是一个字典结构，但这种字典结构却通过严谨而精巧的语法表现出了丰富的外观。正如量子力学在一些地方用粒子来 解释和处理问题，而在另一些地方却用波来解释和处理问题。你也可以在需要的时候，自由选择用对象还是数组来解释和处理问题。只要善于把握 JavaScript的这些奇妙特性，就可以编写出很多简洁而强大的代码来。</p>
<h3 id="放下对象"><a href="#放下对象" class="headerlink" title="放下对象"></a>放下对象</h3><hr>
<p>​        我们再来看看function与object的超然结合吧。<br>​    在面向对象的编程世界里，数据与代码的有机结合就构成了对象的概念。自从有了对象，编程世界就被划分成两部分，一个是对象内的世界，一个是对象外的世界。 对象天生具有自私的一面，外面的世界未经允许是不可访问对象内部的。对象也有大方的一面，它对外提供属性和方法，也为他人服务。不过，在这里我们要谈到一 个有趣的问题，就是“对象的自我意识”。<br>​    什么？没听错吧？对象有自我意识？<br>​    可能对许多程序员来说，这的确是第一次听说。不过，请君看看C++、C#和Java的this，DELPHI的self，还有VB的me，或许你会恍然大悟！当然，也可能只是说句“不过如此”而已。<br>​    然而，就在对象将世界划分为内外两部分的同时，对象的“自我”也就随之产生。“自我意识”是生命的最基本特征！正是由于对象这种强大的生命力，才使得编程世界充满无限的生机和活力。<br>​    但对象的“自我意识”在带给我们快乐的同时也带来了痛苦和烦恼。我们给对象赋予了太多欲望，总希望它们能做更多的事情。然而，对象的自私使得它们互相争抢 系统资源，对象的自负让对象变得复杂和臃肿，对象的自欺也往往带来挥之不去的错误和异常。我们为什么会有这么多的痛苦和烦恼呢？<br>​    为此，有一个人，在对象树下，整整想了九九八十一天，终于悟出了生命的痛苦来自于欲望，但究其欲望的根源是来自于自我意识。于是他放下了“自我”，在对象 树下成了佛，从此他开始普度众生，传播真经。他的名字就叫释迦摩尼，而《JavaScript真经》正是他所传经书中的一本。<br>​    JavaScript中也有this，但这个this却与C++、C#或Java等语言的this不同。一般编程语言的this就是对象自己，而 JavaScript的this却并不一定！this可能是我，也可能是你，可能是他，反正是我中有你，你中有我，这就不能用原来的那个“自我”来理解 JavaScript这个this的含义了。为此，我们必须首先放下原来对象的那个“自我”。<br>​    我们来看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function WhoAmI()       //定义一个函数WhoAmI</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    alert(&quot;I&apos;m &quot; + this.name + &quot; of &quot; + typeof(this));</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">WhoAmI();   //此时是this当前这段代码的全局对象，在浏览器中就是window对象，其name属性为空字符串。输出：I&apos;m of object</div><div class="line"></div><div class="line">var BillGates = &#123;name: &quot;Bill Gates&quot;&#125;;</div><div class="line"></div><div class="line">BillGates.WhoAmI = WhoAmI;  //将函数WhoAmI作为BillGates的方法。</div><div class="line"></div><div class="line">BillGates.WhoAmI();         //此时的this是BillGates。输出：I&apos;m Bill Gates of object</div><div class="line"></div><div class="line">var SteveJobs = &#123;name: &quot;Steve Jobs&quot;&#125;;</div><div class="line"></div><div class="line">SteveJobs.WhoAmI = WhoAmI;  //将函数WhoAmI作为SteveJobs的方法。</div><div class="line"></div><div class="line">SteveJobs.WhoAmI();         //此时的this是SteveJobs。输出：I&apos;m Steve Jobs of object</div><div class="line"></div><div class="line">WhoAmI.call(BillGates);     //直接将BillGates作为this，调用WhoAmI。输出：I&apos;m Bill Gates of object</div><div class="line"></div><div class="line">WhoAmI.call(SteveJobs);     //直接将SteveJobs作为this，调用WhoAmI。输出：I&apos;m Steve Jobs of object</div><div class="line"></div><div class="line">BillGates.WhoAmI.call(SteveJobs);   //将SteveJobs作为this，却调用BillGates的WhoAmI方法。输出：I&apos;m Steve Jobs of object</div><div class="line"></div><div class="line">SteveJobs.WhoAmI.call(BillGates);   //将BillGates作为this，却调用SteveJobs的WhoAmI方法。输出：I&apos;m Bill Gates of object</div><div class="line"></div><div class="line">WhoAmI.WhoAmI = WhoAmI;     //将WhoAmI函数设置为自身的方法。</div><div class="line"></div><div class="line">WhoAmI.name = &quot;WhoAmI&quot;;</div><div class="line"></div><div class="line">WhoAmI.WhoAmI();            //此时的this是WhoAmI函数自己。输出：I&apos;m WhoAmI of function</div><div class="line"></div><div class="line">(&#123;name: &quot;nobody&quot;, WhoAmI: WhoAmI&#125;).WhoAmI();    //临时创建一个匿名对象并设置属性后调用WhoAmI方法。输出：I&apos;m nobody of object</div></pre></td></tr></table></figure>
<p>​    从上面的代码可以看出，同一个函数可以从不同的角度来调用，this并不一定是函数本身所属的对象。this只是在任意对象和function元素结合时的一个概念，是种结合比起一般对象语言的默认结合更加灵活，显得更加超然和洒脱。<br>​    在JavaScript函数中，你只能把this看成当前要服务的“这个”对象。this是一个特殊的内置参数，根据this参数，您可以访问到“这个” 对象的属性和方法，但却不能给this参数赋值。在一般对象语言中，方法体代码中的this可以省略的，成员默认都首先是“自己”的。但 JavaScript却不同，由于不存在“自我”，当访问“这个”对象时，this不可省略！<br>​    JavaScript提供了传递this参数的多种形式和手段，其中，象BillGates.WhoAmI()和SteveJobs.WhoAmI()这 种形式，是传递this参数最正规的形式，此时的this就是函数所属的对象本身。而大多数情况下，我们也几乎很少去采用那些借花仙佛的调用形式。但只我 们要明白JavaScript的这个“自我”与其他编程语言的“自我”是不同的，这是一个放下了的“自我”，这就是JavaScript特有的世界观。</p>
<h3 id="对象素描"><a href="#对象素描" class="headerlink" title="对象素描"></a>对象素描</h3><hr>
<p>​    已经说了许多了许多话题了，但有一个很基本的问题我们忘了讨论，那就是：怎样建立对象？<br>​    在前面的示例中，我们已经涉及到了对象的建立了。我们使用了一种被称为JavaScript Object Notation(缩写JSON)的形式，翻译为中文就是“JavaScript对象表示法”。<br>​    JSON为创建对象提供了非常简单的方法。例如，<br>​    创建一个没有任何属性的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var o = &#123;&#125;;</div></pre></td></tr></table></figure>
<p>​    创建一个对象并设置属性及初始值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var person = &#123;name: &quot;Angel&quot;, age: 18, married: false&#125;;</div></pre></td></tr></table></figure>
<p>​    创建一个对象并设置属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var speaker = &#123;text: &quot;Hello World&quot;, say: function()&#123;alert(this.text)&#125;&#125;;</div></pre></td></tr></table></figure>
<p>​     创建一个更复杂的对象，嵌套其他对象和对象数组等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var company =</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    name: &quot;Microsoft&quot;,</div><div class="line"></div><div class="line">    product: &quot;softwares&quot;,</div><div class="line"></div><div class="line">    chairman: &#123;name: &quot;Bill Gates&quot;, age: 53, Married: true&#125;,</div><div class="line"></div><div class="line">    employees: [&#123;name: &quot;Angel&quot;, age: 26, Married: false&#125;, &#123;name: &quot;Hanson&quot;, age: 32, Marred: true&#125;],</div><div class="line"></div><div class="line">    readme: function() &#123;document.write(this.name + &quot; product &quot; + this.product);&#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>​    JSON的形式就是用大括“{}”号包括起来的项目列表，每一个项目间并用逗号“,”分隔，而项目就是用冒号“:”分隔的属性名和属性值。这是典型的字典 表示形式，也再次表明了 JavaScript里的对象就是字典结构。不管多么复杂的对象，都可以被一句JSON代码来创建并赋值。<br>​    其实，JSON就是JavaScript对象最好的序列化形式，它比XML更简洁也更省空间。对象可以作为一个JSON形式的字符串，在网络间自 由传递和交换信息。而当需要将这个JSON字符串变成一个JavaScript对象时，只需要使用eval函数这个强大的数码转换引擎，就立即能得到一个 JavaScript内存对象。正是由于JSON的这种简单朴素的天生丽质，才使得她在AJAX舞台上成为璀璨夺目的明星。<br>​    JavaScript就是这样，把面向对象那些看似复杂的东西，用及其简洁的形式表达出来。卸下对象浮华的浓妆，还对象一个眉目清晰！</p>
<h3 id="构造对象"><a href="#构造对象" class="headerlink" title="构造对象"></a>构造对象</h3><hr>
<p>​        好了，接下我们来讨论一下对象的另一种创建方法。<br>​    除JSON外，在JavaScript中我们可以使用new操作符结合一个函数的形式来创建对象。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function MyFunc() &#123;&#125;;         //定义一个空函数</div><div class="line"></div><div class="line">var anObj = new MyFunc();  //使用new操作符，借助MyFun函数，就创建了一个对象</div></pre></td></tr></table></figure>
<p>​    JavaScript的这种创建对象的方式可真有意思，如何去理解这种写法呢？<br>   其实，可以把上面的代码改写成这种等价形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function MyFunc()&#123;&#125;;</div><div class="line"></div><div class="line">var anObj = &#123;&#125;;     //创建一个对象</div><div class="line"></div><div class="line">MyFunc.call(anObj); //将anObj对象作为this指针调用MyFunc函数</div></pre></td></tr></table></figure>
<p>​    我们就可以这样理解，JavaScript先用new操作符创建了一个对象，紧接着就将这个对象作为this参数调用了后面的函数。其 实，JavaScript内部就是这么做的，而且任何函数都可以被这样调用！但从 “anObj = new MyFunc()” 这种形式，我们又看到一个熟悉的身影，C++和C#不就是这样创建对象的吗？原来，条条大路通灵山，殊途同归啊！<br>​    君看到此处也许会想，我们为什么不可以把这个MyFunc当作构造函数呢？恭喜你，答对了！JavaScript也是这么想的！请看下面的代码： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function Person(name)   //带参数的构造函数</div><div class="line">      &#123;</div><div class="line">          this.name = name;   //将参数值赋给给this对象的属性</div><div class="line">          this.SayHello = function() &#123;alert(&quot;Hello, I&apos;m &quot; + this.name);&#125;;   //给this对象定义一个SayHello方法。</div><div class="line">      &#125;;</div><div class="line">  </div><div class="line">      function Employee(name, salary)     //子构造函数</div><div class="line">      &#123;</div><div class="line">          Person.call(this, name);        //将this传给父构造函数</div><div class="line">         this.salary = salary;       //设置一个this的salary属性</div><div class="line">         this.ShowMeTheMoney = function() &#123;alert(this.name + &quot; $&quot; + this.salary);&#125;;  //添加ShowMeTheMoney方法。</div><div class="line">     &#125;;</div><div class="line">     </div><div class="line">     var BillGates = new Person(&quot;Bill Gates&quot;);   //用Person构造函数创建BillGates对象</div><div class="line">     var SteveJobs = new Employee(&quot;Steve Jobs&quot;, 1234);   //用Empolyee构造函数创建SteveJobs对象</div><div class="line"> </div><div class="line">     BillGates.SayHello();   //显示：I&apos;m Bill Gates</div><div class="line">     SteveJobs.SayHello();   //显示：I&apos;m Steve Jobs</div><div class="line">     SteveJobs.ShowMeTheMoney();   //显示：Steve Jobs $1234</div><div class="line"> </div><div class="line">     alert(BillGates.constructor == Person);  //显示：true</div><div class="line">     alert(SteveJobs.constructor == Employee);  //显示：true</div><div class="line">     </div><div class="line">     alert(BillGates.SayHello == SteveJobs.SayHello); //显示：false</div></pre></td></tr></table></figure>
<p>​    这段代码表明，函数不但可以当作构造函数，而且还可以带参数，还可以为对象添加成员和方法。其中的第9行，Employee构造函数又将自己接收的 this作为参数调用Person构造函数，这就是相当于调用基类的构造函数。第21、22行还表明这样一个意思：BillGates是由Person构 造的，而SteveJobs是由Employee构造的。对象内置的constructor属性还指明了构造对象所用的具体函数！<br>​    其实，如果你愿意把函数当作“类”的话，她就是“类”，因为她本来就有“类”的那些特征。难道不是吗？她生出的儿子各个都有相同的特征，而且构造函数也与类同名嘛！<br>​    但要注意的是，用构造函数操作this对象创建出来的每一个对象，不但具有各自的成员数据，而且还具有各自的方法数据。换句话说，方法的代码体(体现函数 逻辑的数据)在每一个对象中都存在一个副本。尽管每一个代码副本的逻辑是相同的，但对象们确实是各自保存了一份代码体。上例中的最后一句说明了这一实事， 这也解释了JavaScript中的函数就是对象的概念。<br>​    同一类的对象各自有一份方法代码显然是一种浪费。在传统的对象语言中，方法函数并不象JavaScript那样是个对象概念。即使也有象函数指针、方法指针或委托那样的变化形式，但其实质也是对同一份代码的引用。一般的对象语言很难遇到这种情况。<br>​    不过，JavaScript语言有大的灵活性。我们可以先定义一份唯一的方法函数体，并在构造this对象时使用这唯一的函数对象作为其方法，就能共享方法逻辑。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function SayHello()     //先定义一份SayHello函数代码</div><div class="line"></div><div class="line">  &#123;</div><div class="line"></div><div class="line">      alert(&quot;Hello, I&apos;m &quot; + this.name);</div><div class="line"></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  function Person(name)   //带参数的构造函数</div><div class="line"></div><div class="line">  &#123;</div><div class="line"></div><div class="line">      this.name = name;   //将参数值赋给给this对象的属性</div><div class="line"></div><div class="line">      this.SayHello = SayHello;   //给this对象SayHello方法赋值为前面那份SayHello代码。</div><div class="line"></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  var BillGates = new Person(&quot;Bill Gates&quot;);   //创建BillGates对象</div><div class="line"></div><div class="line">  var SteveJobs = new Person(&quot;Steve Jobs&quot;);   //创建SteveJobs对象</div><div class="line"></div><div class="line">  alert(BillGates.SayHello == SteveJobs.SayHello); //显示：true</div></pre></td></tr></table></figure>
<p>​    其中，最后一行的输出结果表明两个对象确实共享了一个函数对象。虽然，这段程序达到了共享了一份方法代码的目的，但却不怎么优雅。因为，定义 SayHello方法时反映不出其与Person类的关系。“优雅”这个词用来形容代码，也不知道是谁先提出来的。不过，这个词反映了程序员已经从追求代 码的正确、高效、可靠和易读等基础上，向着追求代码的美观感觉和艺术境界的层次发展，程序人生又多了些浪漫色彩。<br>   显然，JavaScript早想到了这一问题，她的设计者们为此提供了一个有趣的prototype概念。</p>
<h3 id="初看原型"><a href="#初看原型" class="headerlink" title="初看原型"></a>初看原型</h3><hr>
<p>​        prototype源自法语，软件界的标准翻译为“原型”，代表事物的初始形态，也含有模型和样板的意义。JavaScript中的prototype概念恰如其分地反映了这个词的内含，我们不能将其理解为C++的prototype那种预先声明的概念。<br>​    JavaScript的所有function类型的对象都有一个prototype属性。这个prototype属性本身又是一个object类型的对 象，因此我们也可以给这个prototype对象添加任意的属性和方法。既然prototype是对象的“原型”，那么由该函数构造出来的对象应该都会具 有这个“原型”的特性。事实上，在构造函数的prototype上定义的所有属性和方法，都是可以通过其构造的对象直接访问和调用的。也可以这么 说，prototype提供了一群同类对象共享属性和方法的机制。<br>​    我们先来看看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function Person(name)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    this.name = name;   //设置对象属性，每个对象各自一份属性数据</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype.SayHello = function()  //给Person函数的prototype添加SayHello方法。</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    alert(&quot;Hello, I&apos;m &quot; + this.name);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var BillGates = new Person(&quot;Bill Gates&quot;);   //创建BillGates对象</div><div class="line"></div><div class="line">var SteveJobs = new Person(&quot;Steve Jobs&quot;);   //创建SteveJobs对象</div><div class="line"></div><div class="line">BillGates.SayHello();   //通过BillGates对象直接调用到SayHello方法</div><div class="line"></div><div class="line">SteveJobs.SayHello();   //通过SteveJobs对象直接调用到SayHello方法</div><div class="line"></div><div class="line">alert(BillGates.SayHello == SteveJobs.SayHello); //因为两个对象是共享prototype的SayHello，所以显示：true</div></pre></td></tr></table></figure>
<p>​    程序运行的结果表明，构造函数的prototype上定义的方法确实可以通过对象直接调用到，而且代码是共享的。显然，把方法设置到prototype的 写法显得优雅多了，尽管调用形式没有变，但逻辑上却体现了方法与类的关系，相对前面的写法，更容易理解和组织代码。<br>​    那么，对于多层次类型的构造函数情况又如何呢？<br>​    我们再来看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function Person(name)   //基类构造函数</div><div class="line">&#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"> Person.prototype.SayHello = function()  //给基类构造函数的prototype添加方法</div><div class="line"> &#123;</div><div class="line">     alert(&quot;Hello, I&apos;m &quot; + this.name);</div><div class="line"> &#125;;</div><div class="line">function Employee(name, salary) //子类构造函数</div><div class="line">&#123;</div><div class="line">    Person.call(this, name);    //调用基类构造函数</div><div class="line">    this.salary = salary;</div><div class="line">&#125;;</div><div class="line">Employee.prototype = new Person();  //建一个基类的对象作为子类原型的原型，这里很有意思</div><div class="line">Employee.prototype.ShowMeTheMoney = function()  //给子类添构造函数的prototype添加方法</div><div class="line">&#123;</div><div class="line">    alert(this.name + &quot; $&quot; + this.salary);</div><div class="line">&#125;;</div><div class="line">var BillGates = new Person(&quot;Bill Gates&quot;);   //创建基类Person的BillGates对象</div><div class="line">var SteveJobs = new Employee(&quot;Steve Jobs&quot;, 1234);   //创建子类Employee的SteveJobs对象</div><div class="line">BillGates.SayHello();       //通过对象直接调用到prototype的方法</div><div class="line">SteveJobs.SayHello();       //通过子类对象直接调用基类prototype的方法，关注！</div><div class="line">SteveJobs.ShowMeTheMoney(); //通过子类对象直接调用子类prototype的方法</div><div class="line">alert(BillGates.SayHello == SteveJobs.SayHello); //显示：true，表明prototype的方法是共享的</div></pre></td></tr></table></figure>
<p>​     这段代码的第17行，构造了一个基类的对象，并将其设为子类构造函数的prototype，这是很有意思的。这样做的目的就是为了第28行，通过子类对象也可以直接调用基类prototype的方法。为什么可以这样呢？</p>
<p>​    原来，在JavaScript中，prototype不但能让对象共享自己财富，而且prototype还有寻根问祖的天性，从而使得先辈们的遗产可以代 代相传。当从一个对象那里读取属性或调用方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的prototype对象那里寻找；如果 prototype没有，又会去prototype自己关联的前辈prototype那里寻找，直到找到或追溯过程结束为止。<br>​    在JavaScript内部，对象的属性和方法追溯机制是通过所谓的prototype链来实现的。当用new操作符构造对象时，也会同时将构造函数的 prototype对象指派给新创建的对象，成为该对象内置的原型对象。对象内置的原型对象应该是对外不可见的，尽管有些浏览器(如Firefox)可以 让我们访问这个内置原型对象，但并不建议这样做。内置的原型对象本身也是对象，也有自己关联的原型对象，这样就形成了所谓的原型链。<br>​    在原型链的最末端，就是Object构造函数prototype属性指向的那一个原型对象。这个原型对象是所有对象的最老祖先，这个老祖宗实现了诸如 toString等所有对象天生就该具有的方法。其他内置构造函数，如Function, Boolean, String, Date和RegExp等的prototype都是从这个老祖宗传承下来的，但他们各自又定义了自身的属性和方法，从而他们的子孙就表现出各自宗族的那些 特征。<br>​    这不就是“继承”吗？是的，这就是“继承”，是JavaScript特有的“原型继承”。<br>​    “原型继承”是慈祥而又严厉的。原形对象将自己的属性和方法无私地贡献给孩子们使用，也并不强迫孩子们必须遵从，允许一些顽皮孩子按自己的兴趣和爱好独立 行事。从这点上看，原型对象是一位慈祥的母亲。然而，任何一个孩子虽然可以我行我素，但却不能动原型对象既有的财产，因为那可能会影响到其他孩子的利益。 从这一点上看，原型对象又象一位严厉的父亲。我们来看看下面的代码就可以理解这个意思了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function Person(name)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        this.name = name;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.company = &quot;Microsoft&quot;; //原型的属性</div><div class="line"></div><div class="line">    Person.prototype.SayHello = function()  //原型的方法</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;Hello, I&apos;m &quot; + this.name + &quot; of &quot; + this.company);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    var BillGates = new Person(&quot;Bill Gates&quot;);</div><div class="line"></div><div class="line">    BillGates.SayHello();   //由于继承了原型的东西，规规矩矩输出：Hello, I&apos;m Bill Gates</div><div class="line"></div><div class="line">    var SteveJobs = new Person(&quot;Steve Jobs&quot;);</div><div class="line"></div><div class="line">    SteveJobs.company = &quot;Apple&quot;;    //设置自己的company属性，掩盖了原型的company属性</div><div class="line"></div><div class="line">    SteveJobs.SayHello = function() //实现了自己的SayHello方法，掩盖了原型的SayHello方法</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;Hi, &quot; + this.name + &quot; like &quot; + this.company + &quot;, ha ha ha &quot;);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    SteveJobs.SayHello();   //都是自己覆盖的属性和方法，输出：Hi, Steve Jobs like Apple, ha ha ha </div><div class="line"></div><div class="line">    BillGates.SayHello();   //SteveJobs的覆盖没有影响原型对象，BillGates还是按老样子输出</div></pre></td></tr></table></figure>
<p>​        对象可以掩盖原型对象的那些属性和方法，一个构造函数原型对象也可以掩盖上层构造函数原型对象既有的属性和方法。这种掩盖其实只是在对象自己身上创建了新 的属性和方法，只不过这些属性和方法与原型对象的那些同名而已。JavaScript就是用这简单的掩盖机制实现了对象的“多态”性，与静态对象语言的虚 函数和重载(override)概念不谋而合。</p>
<p>​    然而，比静态对象语言更神奇的是，我们可以随时给原型对象动态添加新的属性和方法，从而动态地扩展基类的功能特性。这在静态对象语言中是很难想象的。我们来看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function Person(name)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        this.name = name;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.SayHello = function()  //建立对象前定义的方法</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;Hello, I&apos;m &quot; + this.name);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    var BillGates = new Person(&quot;Bill Gates&quot;);   //建立对象</div><div class="line"></div><div class="line">    BillGates.SayHello();</div><div class="line"></div><div class="line">    Person.prototype.Retire = function()    //建立对象后再动态扩展原型的方法</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;Poor &quot; + this.name + &quot;, bye bye!&quot;);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    BillGates.Retire(); //动态扩展的方法即可被先前建立的对象立即调用</div></pre></td></tr></table></figure>
<p>​        阿弥佗佛，原型继承竟然可以玩出有这样的法术！</p>
<h3 id="原型扩展"><a href="#原型扩展" class="headerlink" title="原型扩展"></a>原型扩展</h3><hr>
<p>​        想必君的悟性极高，可能你会这样想：如果在JavaScript内置的那些如Object和Function等函数的prototype上添加些新的方法和属性，是不是就能扩展JavaScript的功能呢？<br>​    那么，恭喜你，你得到了！<br>​    在AJAX技术迅猛发展的今天，许多成功的AJAX项目的JavaScript运行库都大量扩展了内置函数的prototype功能。比如微软的 ASP.NET AJAX，就给这些内置函数及其prototype添加了大量的新特性，从而增强了JavaScript的功能。<br>​    我们来看一段摘自MicrosoftAjax.debug.js中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String.prototype.trim = function String$trim() &#123;</div><div class="line"></div><div class="line">    if (arguments.length !== 0) throw Error.parameterCount();</div><div class="line"></div><div class="line">    return this.replace(/^\s+|\s+$/g, &apos;&apos;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​    这段代码就是给内置String函数的prototype扩展了一个trim方法，于是所有的String类对象都有了trim方法了。有了这个 扩展，今后要去除字符串两段的空白，就不用再分别处理了，因为任何字符串都有了这个扩展功能，只要调用即可，真的很方便。<br>​    当然，几乎很少有人去给Object的prototype添加方法，因为那会影响到所有的对象，除非在你的架构中这种方法的确是所有对象都需要的。<br>​    前两年，微软在设计AJAX类库的初期，用了一种被称为“闭包”(closure)的技术来模拟“类”。其大致模型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">function Person(firstName, lastName, age)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    //私有变量：</div><div class="line"></div><div class="line">    var _firstName = firstName;</div><div class="line"></div><div class="line">    var _lastName = lastName;</div><div class="line"></div><div class="line">    //公共变量:</div><div class="line"></div><div class="line">    this.age = age;</div><div class="line"></div><div class="line">    //方法：</div><div class="line"></div><div class="line">    this.getName = function()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        return(firstName + &quot; &quot; + lastName);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    this.SayHello = function()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;Hello, I&apos;m &quot; + firstName + &quot; &quot; + lastName);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">var BillGates = new Person(&quot;Bill&quot;, &quot;Gates&quot;, 53);</div><div class="line"></div><div class="line">var SteveJobs = new Person(&quot;Steve&quot;, &quot;Jobs&quot;, 53);</div><div class="line"></div><div class="line">BillGates.SayHello();</div><div class="line"></div><div class="line">SteveJobs.SayHello();</div><div class="line"></div><div class="line">alert(BillGates.getName() + &quot; &quot; + BillGates.age);</div><div class="line"></div><div class="line">alert(BillGates.firstName);     //这里不能访问到私有变量</div></pre></td></tr></table></figure>
<p>​    很显然，这种模型的类描述特别象C#语言的描述形式，在一个构造函数里依次定义了私有成员、公共属性和可用的方法，显得非常优雅嘛。特别是“闭包”机制可以模拟对私有成员的保护机制，做得非常漂亮。<br>​    所谓的“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层外层函数体中的临时变量。这使得 只要目标对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失 了，但在目标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量 只是对应新的值，和上次那次调用的是各自独立的。的确很巧妙！<br>​    但是前面我们说过，给每一个对象设置一份方法是一种很大的浪费。还有，“闭包”这种间接保持变量值的机制，往往会给JavaSript的垃圾回收 器制造难题。特别是遇到对象间复杂的循环引用时，垃圾回收的判断逻辑非常复杂。无独有偶，IE浏览器早期版本确实存在JavaSript垃圾回收方面的内 存泄漏问题。再加上“闭包”模型在性能测试方面的表现不佳，微软最终放弃了“闭包”模型，而改用“原型”模型。正所谓“有得必有失”嘛。<br>​    原型模型需要一个构造函数来定义对象的成员，而方法却依附在该构造函数的原型上。大致写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">//定义构造函数</div><div class="line"></div><div class="line">function Person(name)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    this.name = name;   //在构造函数中定义成员</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">//方法定义到构造函数的prototype上</div><div class="line"></div><div class="line">Person.prototype.SayHello = function()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    alert(&quot;Hello, I&apos;m &quot; + this.name);</div><div class="line"></div><div class="line">&#125;;    </div><div class="line"></div><div class="line">//子类构造函数</div><div class="line"></div><div class="line">function Employee(name, salary)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    Person.call(this, name);    //调用上层构造函数</div><div class="line"></div><div class="line">    this.salary = salary;       //扩展的成员</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">//子类构造函数首先需要用上层构造函数来建立prototype对象，实现继承的概念</div><div class="line"></div><div class="line">Employee.prototype = new Person()   //只需要其prototype的方法，此对象的成员没有任何意义！</div><div class="line"></div><div class="line">//子类方法也定义到构造函数之上</div><div class="line"></div><div class="line">Employee.prototype.ShowMeTheMoney = function()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    alert(this.name + &quot; $&quot; + this.salary);</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">var BillGates = new Person(&quot;Bill Gates&quot;);</div><div class="line"></div><div class="line">BillGates.SayHello();    </div><div class="line"></div><div class="line">var SteveJobs = new Employee(&quot;Steve Jobs&quot;, 1234);</div><div class="line"></div><div class="line">SteveJobs.SayHello();</div><div class="line"></div><div class="line">SteveJobs.ShowMeTheMoney();</div></pre></td></tr></table></figure>
<p>​    原型类模型虽然不能模拟真正的私有变量，而且也要分两部分来定义类，显得不怎么“优雅”。不过，对象间的方法是共享的，不会遇到垃圾回收问题，而且性能优于“闭包”模型。正所谓“有失必有得”嘛。</p>
<p>​    在原型模型中，为了实现类继承，必须首先将子类构造函数的prototype设置为一个父类的对象实例。创建这个父类对象实例的目的就是为 了构成原型链，以起到共享上层原型方法作用。但创建这个实例对象时，上层构造函数也会给它设置对象成员，这些对象成员对于继承来说是没有意义的。虽然，我 们也没有给构造函数传递参数，但确实创建了若干没有用的成员，尽管其值是undefined，这也是一种浪费啊。<br>​    唉！世界上没有完美的事情啊！</p>
<h3 id="原型真谛"><a href="#原型真谛" class="headerlink" title="原型真谛"></a>原型真谛</h3><hr>
<p>​    正当我们感概万分时，天空中一道红光闪过，祥云中出现了观音菩萨。只见她手持玉净瓶，轻拂翠柳枝，洒下几滴甘露，顿时让JavaScript又添新的灵气。<br>​    观音洒下的甘露在JavaScript的世界里凝结成块，成为了一种称为“语法甘露”的东西。这种语法甘露可以让我们编写的代码看起来更象对象语言。<br>​    要想知道这“语法甘露”为何物，就请君侧耳细听。<br>​    在理解这些语法甘露之前，我们需要重新再回顾一下JavaScript构造对象的过程。<br>​    我们已经知道，用 var anObject = new aFunction() 形式创建对象的过程实际上可以分为三步：第一步是建立一个新对象；第二步将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象；第 三步就是将该对象作为this参数调用构造函数，完成成员设置等初始化工作。对象建立之后，对象上的任何访问和操作都只与对象自身及其原型链上的那串对象 有关，与构造函数再扯不上关系了。换句话说，构造函数只是在创建对象时起到介绍原型对象和初始化对象两个作用。<br>​    那么，我们能否自己定义一个对象来当作原型，并在这个原型上描述类，然后将这个原型设置给新创建的对象，将其当作对象的类呢？我们又能否将这个原型中的一个方法当作构造函数，去初始化新建的对象呢？例如，我们定义这样一个原型对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">var Person =  //定义一个对象来作为原型类</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    Create: function(name, age)  //这个当构造函数</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        this.name = name;</div><div class="line"></div><div class="line">        this.age = age;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    SayHello: function()  //定义方法</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;Hello, I&apos;m &quot; + this.name);</div><div class="line"></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    HowOld: function()  //定义方法</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(this.name + &quot; is &quot; + this.age + &quot; years old.&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>​    这个JSON形式的写法多么象一个C#的类啊！既有构造函数，又有各种方法。如果可以用某种形式来创建对象，并将对象的内置的原型设置为上面这个“类”对象，不就相当于创建该类的对象了吗？<br>​    但遗憾的是，我们几乎不能访问到对象内置的原型属性！尽管有些浏览器可以访问到对象的内置原型，但这样做的话就只能限定了用户必须使用那种浏览器。这也几乎不可行。<br>​    那么，我们可不可以通过一个函数对象来做媒介，利用该函数对象的prototype属性来中转这个原型，并用new操作符传递给新建的对象呢？<br>​    其实，象这样的代码就可以实现这一目标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">function anyfunc()&#123;&#125;;           //定义一个函数躯壳</div><div class="line"></div><div class="line">anyfunc.prototype = Person;     //将原型对象放到中转站prototype</div><div class="line"></div><div class="line">var BillGates = new anyfunc();  //新建对象的内置原型将是我们期望的原型对象</div></pre></td></tr></table></figure>
<p>​    不过，这个anyfunc函数只是一个躯壳，在使用过这个躯壳之后它就成了多余的东西了，而且这和直接使用构造函数来创建对象也没啥不同，有点不爽。<br>​    可是，如果我们将这些代码写成一个通用函数，而那个函数躯壳也就成了函数内的函数，这个内部函数不就可以在外层函数退出作用域后自动消亡吗？而且，我们可以将原型对象作为通用函数的参数，让通用函数返回创建的对象。我们需要的就是下面这个形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">function New(aClass, aParams)    //通用创建函数</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    function new_()     //定义临时的中转函数壳</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        aClass.Create.apply(this, aParams);   //调用原型中定义的的构造函数，中转构造逻辑及构造参数</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    new_.prototype = aClass;    //准备中转原型对象</div><div class="line"></div><div class="line">    return new new_();          //返回建立最终建立的对象</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">var Person =        //定义的类</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    Create: function(name, age)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        this.name = name;</div><div class="line"></div><div class="line">        this.age = age;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    SayHello: function()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;Hello, I&apos;m &quot; + this.name);</div><div class="line"></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    HowOld: function()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(this.name + &quot; is &quot; + this.age + &quot; years old.&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">var BillGates = New(Person, [&quot;Bill Gates&quot;, 53]);  //调用通用函数创建对象，并以数组形式传递构造参数</div><div class="line"></div><div class="line">BillGates.SayHello();</div><div class="line"></div><div class="line">BillGates.HowOld();</div><div class="line"></div><div class="line">alert(BillGates.constructor == Object);     //输出：true</div></pre></td></tr></table></figure>
<p>​    这里的通用函数New()就是一个“语法甘露”！这个语法甘露不但中转了原型对象，还中转了构造函数逻辑及构造参数。<br>​    有趣的是，每次创建完对象退出New函数作用域时，临时的new<em>函数对象会被自动释放。由于new</em>的prototype属性被设置为新的原型 对象，其原来的原型对象和new_之间就已解开了引用链，临时函数及其原来的原型对象都会被正确回收了。上面代码的最后一句证明，新创建的对象的 constructor属性返回的是Object函数。其实新建的对象自己及其原型里没有constructor属性，那返回的只是最顶层原型对象的构造 函数，即Object。<br>​    有了New这个语法甘露，类的定义就很像C#那些静态对象语言的形式了，这样的代码显得多么文静而优雅啊！<br>​    当然，这个代码仅仅展示了“语法甘露”的概念。我们还需要多一些的语法甘露，才能实现用简洁而优雅的代码书写类层次及其继承关系。好了，我们再来看一个更丰富的示例吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">//语法甘露：</div><div class="line"></div><div class="line">var object =    //定义小写的object基本类，用于实现最基础的方法等</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    isA: function(aType)   //一个判断类与类之间以及对象与类之间关系的基础方法</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        var self = this;</div><div class="line"></div><div class="line">        while(self)</div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            if (self == aType)</div><div class="line"></div><div class="line">              return true;</div><div class="line"></div><div class="line">            self = self.Type;</div><div class="line"></div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        return false;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Class(aBaseClass, aClassDefine)    //创建类的函数，用于声明类及继承关系</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    function class_()   //创建类的临时函数壳</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        this.Type = aBaseClass;    //我们给每一个类约定一个Type属性，引用其继承的类</div><div class="line"></div><div class="line">        for(var member in aClassDefine)</div><div class="line"></div><div class="line">            this[member] = aClassDefine[member];    //复制类的全部定义到当前创建的类</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    class_.prototype = aBaseClass;</div><div class="line"></div><div class="line">    return new class_();</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">function New(aClass, aParams)   //创建对象的函数，用于任意类的对象创建</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    function new_()     //创建对象的临时函数壳</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        this.Type = aClass;    //我们也给每一个对象约定一个Type属性，据此可以访问到对象所属的类</div><div class="line"></div><div class="line">        if (aClass.Create)</div><div class="line"></div><div class="line">          aClass.Create.apply(this, aParams);   //我们约定所有类的构造函数都叫Create，这和DELPHI比较相似</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    new_.prototype = aClass;</div><div class="line"></div><div class="line">    return new new_();</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">//语法甘露的应用效果：    </div><div class="line"></div><div class="line">var Person = Class(object,      //派生至object基本类</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    Create: function(name, age)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        this.name = name;</div><div class="line"></div><div class="line">        this.age = age;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    SayHello: function()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(&quot;Hello, I&apos;m &quot; + this.name + &quot;, &quot; + this.age + &quot; years old.&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">var Employee = Class(Person,    //派生至Person类，是不是和一般对象语言很相似？</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    Create: function(name, age, salary)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        Person.Create.call(this, name, age);  //调用基类的构造函数</div><div class="line"></div><div class="line">        this.salary = salary;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    ShowMeTheMoney: function()</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        alert(this.name + &quot; $&quot; + this.salary);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">var BillGates = New(Person, [&quot;Bill Gates&quot;, 53]);</div><div class="line"></div><div class="line">var SteveJobs = New(Employee, [&quot;Steve Jobs&quot;, 53, 1234]);</div><div class="line"></div><div class="line">BillGates.SayHello();</div><div class="line"></div><div class="line">SteveJobs.SayHello();</div><div class="line"></div><div class="line">SteveJobs.ShowMeTheMoney();</div><div class="line"></div><div class="line">var LittleBill = New(BillGates.Type, [&quot;Little Bill&quot;, 6]);   //根据BillGate的类型创建LittleBill</div><div class="line"></div><div class="line">LittleBill.SayHello();</div><div class="line"></div><div class="line">alert(BillGates.isA(Person));       //true</div><div class="line"></div><div class="line">alert(BillGates.isA(Employee));     //false</div><div class="line"></div><div class="line">alert(SteveJobs.isA(Person));       //true</div><div class="line"></div><div class="line">alert(Person.isA(Employee));        //false</div><div class="line"></div><div class="line">alert(Employee.isA(Person));        //true</div></pre></td></tr></table></figure>
<p>​    “语法甘露”不用太多，只要那么一点点，就能改观整个代码的易读性和流畅性，从而让代码显得更优雅。有了这些语法甘露，JavaScript就很像一般对象语言了，写起代码了感觉也就爽多了！<br>​    令人高兴的是，受这些甘露滋养的JavaScript程序效率会更高。因为其原型对象里既没有了毫无用处的那些对象级的成员，而且还不存在 constructor属性体，少了与构造函数间的牵连，但依旧保持了方法的共享性。这让JavaScript在追溯原型链和搜索属性及方法时，少费许多 工夫啊。<br>​    我们就把这种形式称为“甘露模型”吧！其实，这种“甘露模型”的原型用法才是符合prototype概念的本意，才是的JavaScript原型的真谛！<br>​    想必微软那些设计AJAX架构的工程师看到这个甘露模型时，肯定后悔没有早点把AJAX部门从美国搬到咱中国的观音庙来，错过了观音菩萨的点化。 当然，我们也只能是在代码的示例中，把Bill Gates当作对象玩玩，真要让他放弃上帝转而皈依我佛肯定是不容易的，机缘未到啊！如果哪天你在微软新出的AJAX类库中看到这种甘露模型，那才是真正 的缘分！</p>
<h3 id="编程的快乐"><a href="#编程的快乐" class="headerlink" title="编程的快乐"></a>编程的快乐</h3><hr>
<p>​        在软件工业迅猛发展的今天，各式各样的编程语言层出不穷，新语言的诞生，旧语言的演化，似乎已经让我们眼花缭乱。为了适应面向对象编程的潮 流，JavaScript语言也在向完全面向对象的方向发展，新的JavaScript标准已经从语义上扩展了许多面向对象的新元素。与此相反的是，许多 静态的对象语言也在向JavaScript的那种简洁而幽雅的方向发展。例如，新版本的C#语言就吸收了JSON那样的简洁表示法，以及一些其他形式的 JavaScript特性。<br>​    我们应该看到，随着RIA(强互联应用)的发展和普及，AJAX技术也将逐渐淡出江湖，JavaScript也将最终消失或演化成其他形式的语 言。但不管编程语言如何发展和演化，编程世界永远都会在“数据”与“代码”这千丝万缕的纠缠中保持着无限的生机。只要我们能看透这一点，我们就能很容易地 学习和理解软件世界的各种新事物。不管是已熟悉的过程式编程，还是正在发展的函数式编程，以及未来量子纠缠态的大规模并行式编程，我们都有足够的法力来化 解一切复杂的难题。<br>​    佛最后淡淡地说：只要我们放下那些表面的“类”，放下那些对象的“自我”，就能达到一种“对象本无根，类型亦无形”的境界，从而将自我融入到整个 宇宙的生命轮循环中。我们将没有自我，也没有自私的欲望，你就是我，我就是你，你中有我，我中有你。这时，我们再看这生机勃勃的编程世界时，我们的内心将 自然生起无限的慈爱之心，这种慈爱之心不是虚伪而是真诚的。关爱他人就是关爱自己，就是关爱这世界中的一切。那么，我们的心是永远快乐的，我们的程序是永 远快乐的，我们的类是永远快乐的，我们的对象也是永远快乐的。这就是编程的极乐！<br>​    说到这里，在座的比丘都犹如醍醐灌顶，心中豁然开朗。看看左边这位早已喜不自禁，再看看右边那位也是心花怒放。<br>​    蓦然回首时，唯见君拈花微笑…<br>原著：李战(leadzen).深圳</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[转载]web前端开发学习路线]]></title>
      <url>/2017/07/13/%E8%BD%AC%E8%BD%BD-web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      <content type="html"><![CDATA[<p>导语** 　 首先分享一下我的经验，想做好一件事，必须要花费一些功夫，然后是多学、多思、多练、多交流、多总结，发现自己的问题，然后一定要克服，在状态不好的情况下，往往要及时调整。新手学习前端的话，一定要想想</p>
<p>首先分享一下我的经验，想做好一件事，必须要花费一些功夫，然后是多学、多思、多练、多交流、多总结，发现自己的问题，然后一定要克服，在状态不好的情况下，往往要及时调整。新手学习前端的话，一定要想想为什么要学习它，是出于一种什么心态，然后定位好自己，多向大牛请教，多教一些没有自己水平高的人，那样往往能让自己成长的快，切勿急躁。初学可以看一些入门视频教程，之后可以买一些书，做一些小项目，要学会投资，分析自己的现状及能力，实时调整，一定要有自己的想法，懂得创新。在这里一定要对自己做分析，然后找出一种适合的学习方法。</p>
<p>　　<strong>Web前端的学习误区</strong></p>
<p>　　网页制作是计算机专业同学在大学期间都会接触到的一门课程，而学习网页制作所用的第一个集成开发环境(IDE)想必大多是Dreamweaver，这种所见即所得的“吊炸天”IDE为我们制作网页带来了极大的方便。</p>
<p>　　入门快、见效快让我们在不知不觉中已经深深爱上了网页制作。此时，很多人会陷入一个误区，那就是既然借助这么帅的IDE，通过鼠标点击菜单就可以快速方便地制作网页。</p>
<p>　　那么我们为什么还要去学习HTML、CSS、JavaScrpt、jQuery等这些苦逼的代码呢?这不是舍简求繁吗?</p>
<p>　　但是随着学习的深入，就会发现我们步入了一种窘境——过分的依赖IDE导致我们不清楚其实现的本质，知其然但不知其所以然。</p>
<p>　　因此在页面效果出现问题时，我们便手足无措，更不用提如何进行页面优化以及完成一些更高级的应用了。其原因是显而易见的——聪明的IDE成全了我们的惰性，使我们忽略了华丽的网页背后最本质的内容——code。</p>
<p>　　<strong>正确的方向胜过无谓的努力</strong></p>
<p>　　有两只蚂蚁想翻越一段墙，寻找墙那头的食物。一只蚂蚁来到墙脚就毫不犹豫地向上爬去，可是每当它爬到大半时，就会由于劳累、疲倦而跌落下来。虽然它不气馁，一次次跌下来，又迅速地调整一下自己，重新开始向上爬去。</p>
<p>　　另一只蚂蚁观察了一下，决定绕过墙去。很快，这只蚂蚁绕过墙来到食物前，开始享受起来;而另一只蚂蚁还在不停地跌落下去又重新开始。</p>
<p>　　很多时候，成功除了勇气、坚持不懈外，更需要方向。也许有了一个好的方向，成功来得比想象的更快。如果在错误的路上奔跑,再怎么努力也是白搭。学习Web前端也是如此，首先应该选择一个正确的学习路线。</p>
<p>　　<strong>Web前端的学习路线</strong></p>
<table>
<thead>
<tr>
<th><img src="http://osprtpxhb.bkt.clouddn.com/20150509103253492.jpg" alt="\"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>结合我的学习经历、近年来辅导学生的经验以及公司中实际项目的需求，在这里将Web前端的学习分为以下几个阶段，具体的学习路线图如图所示。</p>
<p>　</p>
<p>　第一阶段——HTML的学习</p>
<p>　　超文本标记语言(HyperText Mark-up Language 简称HTML)是一个网页的骨架，无论是静态网页还是动态网页，最终返回到浏览器端的都是HTML代码，浏览器将HTML代码解释渲染后呈现给用户。因 此，我们必须掌握HTML的基本结构和常用标记及属性。</p>
<p>　　HTML 的学习是一个记忆和理解的过程，在学习过程中可以借助Dreamweaver的“拆分”视图辅助学习。在“设计”视图中看效果，在“代码”视图中学本质， 将各种视图的优势发挥到极致，这种对照学习的方法弥补了单纯识记HTML标签和属性的枯燥乏味，想必对各位初学的小盆友们来说必定是极好的!</p>
<p>　　在学习了HTML之后，我们只是掌握了各种“原材料”的制作方法，要想盖一幢楼房就还需要把这些“原材料”按照我们设计的方案组合布局在一起并进行一些样式的美化。</p>
<p>　　</p>
<p>第二个阶段——CSS的学习</p>
<p>　　CSS是英文Cascading Style Sheets的缩写，叫做层叠样式表，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言其样式是可以复用的，这样就极大地提高了我们开发的速度，降低了维护的成本。</p>
<p>　　同时CSS中的盒子模型、相对布局、绝对布局等能够实现对网页中各对象的位置排版进行像素级的精确控制。通过此阶段的学习，我们就可以顺利完成“一幢楼房”的建设。</p>
<p>　　“楼房”建设完成之后，我们可以交给用户使用，但是如果想让用户获得更佳的体验，我们还可以对“楼房”进行更深一步的“装修”，让它看起来更“豪华”一些。</p>
<p>　　</p>
<p>第三个阶段——JavaScript的学习</p>
<p>　　JavaScript是一种在客户端广泛使用的脚步语言，在JavaScript当中为我们提供了一些内置函数、对象和DOM操作，借助这些内容我们可以来实现一些客户端的特效、验证、交互等，使我们的页面看起来不那么呆板，屌丝瞬间逆袭高富帅!有么有?</p>
<p>　　此时，也许你还沉浸在JavaScript给你带来的惊喜之中，但你的项目经理却突然对你大吼道</p>
<p>　　“这个效果在××浏览器下不兼容，重新搞……”</p>
<p>　　“不兼容?”瞬间石化了有木有?</p>
<p>　　“我擦，坑爹啊!那可是花了我一个晚上写了几百行代码搞定的啊，吐血了都!”</p>
<p>　　JavaScript的兼容性和复杂性有时候的确让我们头疼，还好有“大神”帮我们做了封装。</p>
<p>　　</p>
<p>第四个阶段——jQUery的学习</p>
<p>　　jQuery 是一个免费、开源的轻量级的JavaScript库，并且兼容各种浏览器(jQuery2.0及后续版本放弃了对IE6/7/8浏览器的支持)，同时现在有很多基于jQuery的插件可供选择，这样在我们实现一些丰富的动态效果时更方便快捷，大大节省了我们开发的时间，提高了开发速度，这也充分体现了其 write less,do more的核心宗旨。这个Feel倍儿爽!有么有?</p>
<p>　　“豪华大楼”至此拔地而起，但是每天这样日复一日，年复一年的盖楼，好繁琐!能不能将大楼里面每一个单独部件模块化，当需要盖楼时就像堆积木一样组合在一起，这样岂不是爽歪歪?可以实现吗?答案是肯定的。</p>
<p>　　这种思想在Web</p>
<p>前端开发</p>
<p>中也是适合的，于是乎就出现了各种前端框架，在这里推荐给大家的是Bootstrap。</p>
<p>　　Bootstrap是Twitter推出的一个开源的用于</p>
<p>前端开发</p>
<p>的工具包，是一个CSS/HTML框架，并且支持响应式布局。一经推出后颇受欢迎，一直是GitHub上的热门开源项目。</p>
<p>　　在项目开发过程中，我们可以借助Bootstrap提供的CSS样式、组件、JavaScript插件等快速的完成页面布局和样式设置，然后再有针对性的微调样式，这样基于框架进行开发大大缩短了开发周期。站在巨人的肩膀上就是爽!</p>
<p>　　</p>
<p>Web<a href="http://www.aseoe.com/" target="_blank" rel="external">前端</a>的学习建议</p>
<p>　　最后给大家聊聊在学习Web</p>
<p>前端</p>
<p>中的一些建议和方法。</p>
<p>　　在CSS布局时需要注意的一个问题是很多同学缺乏对页面布局进行整体分析，不能够从宏观上对页面中盒子间的嵌套关系进行把握，就急于动手去做，导致页面中各元素间的关系很混乱，容易出现盒子在浮动时错位等情况。建议大家在布局时采用“自顶向下，逐步细化”的思想，先用几个盒子将页面从整体上划分，然后逐步在盒子中继续嵌套盒子。</p>
<p>　　“君子生非异也，善假于物也”，在学习的过程中还要多浏览一些优秀的网站，善于分析借鉴其设计思路和布局方法，见多方能识广，进而才可以融会贯通，取他人之长为我所用。</p>
<p>　　同时还要善于使用Firebug这个利器。Firebug一方面可以在我们学习过程中帮助我们调试自己的页面，另一方面我们可以使用Firebug方便地查看、分析别人网站的源代码，“偷”也是一种技能!</p>
<blockquote>
<p>每个人的成长与基础不一样，结合自己的实际情况，在执行。还是重复一下，前端的核心是js。css不难，但需要来积累。对前端我是这么看的：</p>
<p><strong>css就像一瓶酒，得品。</strong></p>
<blockquote>
<p>html,css总共就那些标签跟选择器属性什么的，但是要写一个有扩展性，健壮性或维护性的页面不容易。现在写页面基本条件反射，不是如何快速的完成，而是思考如果有界面需求修改，怎么在修改代码最少的情况下快速完成需求任务。这是对前端耐力，体力，智力的三重考验。</p>
</blockquote>
<p><strong>js就像一把剑，得磨。</strong></p>
<blockquote>
<p>js刚开始只是为了较验，随便技术社会的发展，承担的角色越来越重，刚开始玩玩jQuery感觉已经会js了，其实只是冰山一角。随着对js的了解越来越多，他即变态又可爱，即好玩又难控，即有很多兼容问题，但解决兼容是我们基本生存之道。从ajax到jsmvc一路走一路看，高载潮一浪高过一浪</p>
</blockquote>
<p><strong>人生就是一场梦，得作。</strong></p>
<blockquote>
<p>技术只是生活的一部分，曾经雄心斗志，如今低头写码。改变能改变的，接受不能改变的。人生有限，兄争朝夕啊。人生学习的态度是：不急不躁，不快不慢。持之以恒，相信自己。不求能改变世界，但求能改变自己的生活。不求健步如飞，但求一步一脚印。感谢磨难，他使我们内心更为坚强。感谢挫折，他使我们不断的成长，感谢bug，他使我们的思维更加深邃。感谢前端，他使我们更加的相信，撑起一片天空需要十八般武艺。</p>
</blockquote>
</blockquote>
<p>文章部分内容来自于互联网，学对自己有用的东西，感觉有不对的地方可以直接无视，只是一个参考，愿大家的前端之路越走越远。</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 前端路线 </tag>
            
            <tag> 路线思路 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[生活本身就是一种承受！]]></title>
      <url>/2017/07/12/%E7%94%9F%E6%B4%BB%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%B8%80%E7%A7%8D%E6%89%BF%E5%8F%97%EF%BC%81/</url>
      <content type="html"><![CDATA[<p>人生的美，在于缘分;缘分的美，在于相遇;相遇的美，在于相知;相知的美，在于懂得。生命中，总有一个懂你的人，即便不联系，那份牵挂却一直在，懂得，是灵魂相拥的美丽;懂得，是心与心的相惜;懂得，是缘分最美的遇见……</p>
<p>人生有两种境界：一是痛而不言，二是笑而不语。痛而不言是一种智慧，笑而不语是一种豁达。人生在世，往往会因这样或那样的伤害而心痛不已。对坚强的人来说，顽强的是生命赐予的最好礼物……</p>
<p>文字终究是点滴，念想，且沧桑。执笔也只是心路的悲与喜，或回忆，或感慨，别无它意。经年过后，仍浅笑若梦，红尘只是回眸一笑，仅此而已……</p>
<p>许久不联系的人，不用再联系。各自辛苦，各自生活，也再无交集，该停留在过去的，就让它停留在过去。如果有缘，会再见。若无缘，不如不见。就是这样……</p>
<p>我们要学会享受平淡，平淡如同清茶，点缀着生活的宁静和温馨;我们要学会承受平淡，学会承受淡淡的孤寂与失落，承受那挥之不去的枯燥与沉寂，还要承受那遥遥无期的等待与无奈。生活本身就是一种承受……</p>
<p>凡事不必太在意，一切随缘随心，缘深多聚聚，缘浅随它去。凡事看淡点看开些，顺其自然，无意于得，就无所谓失。人生，看轻看淡多少，痛苦就远离你多少……对于孤独，有时是心之选择;对于承受，时常是人之担当。人生的必经路，生活的必修课，那就是，只有经历才会懂得。</p>
<p>如果你相信命，那么一切的偶然都是注定。如果你不相信命，那么一切的注定都是偶然。人生得意时，记得看淡，人生失意时，记得随缘。任春去秋来，花开花落，学一种洒脱，学一种恬淡，看人间冷暖，赏天高云淡……</p>
]]></content>
      
        <categories>
            
            <category> 经典语录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经典语录 </tag>
            
            <tag> 美文欣赏 </tag>
            
            <tag> 励志名言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[聊一聊ES6中class的使用]]></title>
      <url>/2017/07/12/%E8%81%8A%E4%B8%80%E8%81%8AES6%E4%B8%ADclass%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>javascript传统做法是当生成一个对象实例，需要定义构造函数，然后通过new的方式完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function StdInfo()&#123;</div><div class="line">    this.name = &quot;job&quot;;</div><div class="line">    this.age = 30;</div><div class="line">&#125;</div><div class="line">StdInfo.prototype.getNames = function ()&#123;</div><div class="line">    console.log(&quot;name：&quot;+this.name);</div><div class="line">&#125;</div><div class="line">//得到一个学员信息对象</div><div class="line">var p = new StdInfo()</div></pre></td></tr></table></figure>
<p>javacript中只有对象，没有类。它是是基于原型的语言，原型对象是新对象的模板，它将自身的属性共享给新对象。这样的写法和传统面向对象语言差异很大，很容易让新手感到困惑。</p>
<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><hr>
<p>到了ES6添加了类，作为对象的模板。通过class来定义一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//定义类</div><div class="line">class StdInfo &#123;</div><div class="line">    constructor()&#123;</div><div class="line">       this.name = &quot;job&quot;;</div><div class="line">       this.age = 30;</div><div class="line">    &#125;</div><div class="line">    //定义在类中的方法不需要添加function</div><div class="line">    getNames()&#123;</div><div class="line">       console.log(&quot;name：&quot;+this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//使用new的方式得到一个实例对象</div><div class="line">var p = new StdInfo();</div></pre></td></tr></table></figure>
<p>上面的写法更加清晰、更像面向对象编程的语法，看起来也更容易理解。</p>
<p>定义的类只是语法糖，目的是让我们用更简洁明了的语法创建对象及处理相关的继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//定义类</div><div class="line">class StdInfo &#123;</div><div class="line">    //...</div><div class="line">&#125;</div><div class="line">console.log(typeof  StdInfo);  //function</div><div class="line">console.log(StdInfo === StdInfo.prototype.constructor);  //true</div></pre></td></tr></table></figure>
<p>从上面的测试中可以看出来，类的类型就是一个函数，是一个“特殊函数”，指向的是构造函数。</p>
<p>函数的定义方式有函数声明和函数表达式两种，类的定义方式也有两种，分别是：<code>类声明</code>和<code>类表达式</code>。</p>
<h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>类声明是定义类的一种方式，使用关键字class，后面跟上类名，然后就是一对大括号。把这一类需要定义的方法放在大括号中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//定义类，可以省略constructor</div><div class="line">class StdInfo &#123;</div><div class="line">    getNames()&#123;</div><div class="line">        console.log(&quot;name：&quot;+this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// -------------------------------------</div><div class="line">//定义类，加上constructor</div><div class="line">class StdInfo &#123;</div><div class="line">    //使用new定义实例对象时，自动调用这个函数，传入参数</div><div class="line">    constructor(name,age)&#123;</div><div class="line">       this.name = name;</div><div class="line">       this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getNames()&#123;</div><div class="line">       console.log(&quot;name：&quot;+this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//定义实例对象时，传入参数</div><div class="line">var p = new StdInfo(&quot;job&quot;,30)</div></pre></td></tr></table></figure>
<p><code>constructor</code>是一个默认方法，使用<code>new</code>来定义实例对象时，自动执行<code>constructor</code>函数，传入所需要的参数,执行完<code>constructor</code>后自动返回实例对象。</p>
<p>一个类中只能有一个<code>constructor</code>函数，定义多个会报错。</p>
<p><code>constructor</code>中的<code>this</code>指向新创建的实例对象，利用this往新创建的实例对象扩展属性。</p>
<p>在定义实例对象时，不需要在初始化阶段做一些事，可以不用显示的写constructor函数。如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加，<code>constructor(){}</code></p>
<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>类表达式是定义类的另一种形式，类似于函数表达式，把一个函数作为值赋给变量。可以把定义的类赋值给一个变量，这时候变量就为类名。class关键字之后的类名可有可无，如果存在，则只能在类内部使用。</p>
<p>定义类 class后面有类名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const People = class StdInfo &#123;</div><div class="line">    constructor()&#123;</div><div class="line">        console.log(StdInfo);  //可以打印出值，是一个函数</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">new People();</div><div class="line">new StdInfo();  //报错，StdInfo is not defined；</div></pre></td></tr></table></figure>
<p>定义类 class后面没有类名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const People = class &#123;</div><div class="line">    constructor()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">new People();</div></pre></td></tr></table></figure>
<p>立即执行的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const p = new class &#123;</div><div class="line">    constructor(name,age)&#123;</div><div class="line">        console.log(name,age);</div><div class="line">    &#125;</div><div class="line">&#125;(&quot;job&quot;,30)</div></pre></td></tr></table></figure>
<p>立即执行的类，在类前要加上new。p为类的实例对象。</p>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>定义类不存在变量提升，只能先定义类后使用，跟函数声明有区别的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//-----函数声明-------</div><div class="line">//定义前可以先使用，因为函数声明提升的缘故，调用合法。</div><div class="line">func();</div><div class="line">function func()&#123;&#125;</div><div class="line"></div><div class="line">//-----定义类---------------</div><div class="line">new StdInfo();  //报错，StdInfo is not defined</div><div class="line">class StdInfo&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="extends继承"><a href="#extends继承" class="headerlink" title="extends继承"></a>extends继承</h3><p>使用<code>extends</code>关键字实现类之间的继承。这比在ES5中使用继承要方便很多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//定义类父类</div><div class="line">class Parent &#123;</div><div class="line">    constructor(name,age)&#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    speakSometing()&#123;</div><div class="line">        console.log(&quot;I can speek chinese&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//定义子类，继承父类</div><div class="line">class Child extends Parent &#123;</div><div class="line">    coding()&#123;</div><div class="line">        console.log(&quot;coding javascript&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var c = new Child();</div><div class="line"></div><div class="line">//可以调用父类的方法</div><div class="line">c.speakSometing(); // I can speek chinese</div></pre></td></tr></table></figure>
<p>使用继承的方式，子类就拥有了父类的方法。</p>
<p>如果子类中有constructor构造函数，则必须使用调用super。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//定义类父类</div><div class="line">class Parent &#123;</div><div class="line">    constructor(name,age)&#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    speakSometing()&#123;</div><div class="line">        console.log(&quot;I can speek chinese&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//定义子类，继承父类</div><div class="line">class Child extends Parent &#123;</div><div class="line">    constructor(name,age)&#123;</div><div class="line">        //不调super()，则会报错  this is not defined</div><div class="line"></div><div class="line">        //必须调用super</div><div class="line">        super(name,age);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    coding()&#123;</div><div class="line">        console.log(&quot;coding javascript&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var c = new Child(&quot;job&quot;,30);</div><div class="line"></div><div class="line">//可以调用父类的方法</div><div class="line">c.speakSometing(); // I can speek chinese</div></pre></td></tr></table></figure>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错(this is not defined)。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<p>以上是对ES6中类的简单总结学习，欢迎一起讨论。<br>参考：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes</a></p>
<p><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/class</a></p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript开发应用小实例]]></title>
      <url>/2017/07/12/JavaScript%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8%E5%B0%8F%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>1.1输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html PUBLIC&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</div><div class="line">&lt;htmlxmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">         &lt;meta http-equiv=&quot;Content-Type&quot;content=&quot;text/html;charset=UTF-8&quot;&gt;</div><div class="line">         &lt;title&gt;&lt;/title&gt;</div><div class="line">&lt;body&gt;   </div><div class="line">&lt;input type=&quot;button&quot; value=&quot;关闭窗口&quot;onclick=&quot;window.close();&quot;/&gt;</div><div class="line">         &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">         &lt;!—</div><div class="line">                   //输出方法</div><div class="line">                  document.write(&quot;您好，现在时间为：&quot;+newDate());</div><div class="line">         --&gt;</div><div class="line">         &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>（注：以后只写Scrip内部的东西;<br>注释在代码右边，极少在上面，绝不在下面）</p>
<p>2.1变量的赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var username = &quot;Tom&quot;;//声明变量username并赋值&quot;Tom&quot;</div><div class="line">var account = 4500;  //声明变量account并赋值4500</div><div class="line">age = 23;             //未声明直接为变量age赋值23</div><div class="line">var marriaged ;          //声明变量marriaged未赋值</div></pre></td></tr></table></figure></p>
<p>2.2变量的练习<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = 3,b=5;            //声明全局变量a</div><div class="line">function add(x,y)&#123;     //这里参数x和y为局部变量</div><div class="line">  var c = 6;                //局部变量c</div><div class="line">  return x + y;&#125;</div><div class="line">document.write(&quot;&lt;h2&gt;a + b =&quot; + add(a,b)+&quot;&lt;h2&gt;&quot;);</div><div class="line">document.write(&quot;c的值为：&quot; + c);//这里会发生错误，c的值未定义</div></pre></td></tr></table></figure></p>
<p>2.3数据类型转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a;　//声明变量a，因为没有赋值此值为undefined</div><div class="line">var b = null;</div><div class="line">var c = &quot;100&quot;;</div><div class="line">d = parseInt(c) + b;           //c由字符转为数值</div><div class="line">document.write(&quot;a转换为数值型的结果是：&quot; + parseInt(a) +&quot;&lt;br/&gt;&quot;);</div></pre></td></tr></table></figure></p>
<p>2.4数据类型转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var a = undefined;</div><div class="line">var b = null;</div><div class="line">var str1 = &quot;&quot;,str2 = &quot;hello123&quot;;        //声明两个字符型变量，其值分别为空和&quot;hello123&quot;</div><div class="line">var num1 = 0,num2 = NaN,num3=38;     //声明三个数值型变量，其值分别为0，NaN和38</div><div class="line">var obj = new Object();    //这里创建了一个对象，名称为obj</div><div class="line">with(document)&#123;      //对象的with用法</div><div class="line">write(&quot;undefined转换后的值为：&quot;+ new Boolean(a) +&quot;&lt;br/&gt;&quot;);         //将a转为布尔型false</div><div class="line">write(&quot;null转换后的值为：&quot;+ new Boolean(b) +&quot;&lt;br/&gt;&lt;hr&gt;&quot;);   //将b转为布尔型false</div><div class="line">write(&quot;空字符串转换后的值为：&quot;+ new Boolean(str1) +&quot;&lt;br/&gt;&quot;);              //转为布尔型false</div><div class="line">write(&quot;非空字符串转换后的值为：&quot; + new Boolean(str2) +&quot;&lt;br/&gt;&lt;hr&gt;&quot;);//转为布尔型true</div><div class="line">write(&quot;0转换后的值为：&quot; + new Boolean(num1) +&quot;&lt;br/&gt;&quot;);//转为布尔型false</div><div class="line">write(&quot;NaN转换后的值为：&quot; + new Boolean(num2) +&quot;&lt;br/&gt;&quot;);//转为布尔型false</div><div class="line">write(&quot;非0和NaN数值转换后的值为：&quot; + new Boolean(num3) +&quot;&lt;br/&gt;&lt;hr&gt;&quot;);//转为布尔型true</div><div class="line">write(&quot;对象转换后的值为:&quot;+new Boolean(obj) +&quot;&lt;br/&gt;&quot;); //转为布尔型true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.1算术运算符练习<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var sum1 = 10,sum2 = 3;</div><div class="line">result = &quot;字符串&quot; + sum1 + sum2;　//结果为字符串</div><div class="line">with(document)&#123;</div><div class="line">write(&quot;&lt;p&gt;sum1= &quot; +  sum1 + &quot; , sum2 = &quot;+ sum2 + &quot;&lt;p/&gt;&quot;); //输出数值</div><div class="line">write(&quot;&lt;li&gt;sum1+ sum2 = &quot; + (sum1 + sum2) + &quot;&lt;/li&gt;&quot;);　　//输出数值（加减乘除道理一样）</div><div class="line">write(&quot;&lt;li&gt;sum1%sum2=&quot;+(sum1%sum2)+&quot;&lt;/li&gt;&quot;);//求余</div><div class="line">write(&quot;&lt;li&gt;result= &quot; + result + &quot;&lt;/li&gt;&quot;);</div><div class="line">write(&quot;&lt;li&gt;++sum1=&quot;+++sum1+&quot;&lt;/li&gt;&quot;);//自加</div><div class="line">write(&quot;&lt;li&gt;sum2--=&quot;+sum2--+&quot;&lt;/li&gt;&quot;);//自减</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更多实例请看文档<br><a href="http://osprtpxhb.bkt.clouddn.com/JavaScript%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8%E5%B0%8F%E5%AE%9E%E4%BE%8B.docx" target="_blank" rel="external">http://osprtpxhb.bkt.clouddn.com/JavaScript%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8%E5%B0%8F%E5%AE%9E%E4%BE%8B.docx</a></p>
]]></content>
      
        <categories>
            
            <category> 插件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[flexslider插件]]></title>
      <url>/2017/07/11/flexslider%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>FlexSlider插件的详细设置参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">$(window).load(function() &#123;</div><div class="line">    $(&apos;.flexslider&apos;).flexslider(&#123;</div><div class="line"></div><div class="line">        namespace: &apos;flex-&apos;,    //控件的命名空间，会影响样式前缀 </div><div class="line">        animation: &quot;slide&quot;, //String: Select your animation type, &quot;fade&quot; or &quot;slide&quot;图片变换方式：淡入淡出或者滑动</div><div class="line">        slideDirection: &quot;horizontal&quot;, //String: Select the sliding direction, &quot;horizontal&quot; or &quot;vertical&quot;图片设置为滑动式时的滑动方向：左右或者上下</div><div class="line"></div><div class="line">        selector: &apos;.thumbnails .thumbnail&apos;,</div><div class="line">        slideshowSpeed: 5000, // 自动播放速度毫秒</div><div class="line">        animationSpeed: 600, //滚动效果播放时长</div><div class="line">        pausePlay: false,//是否显示播放暂停按钮</div><div class="line">        minItems: common.globals.SCREEN.ITEM,//最少显示多少项</div><div class="line">        itemWidth: 220,//一个滚动项目的宽度</div><div class="line">        itemMargin: 20,//滚动项目之间的间距</div><div class="line">        slideshow: true, //Boolean: Animate slider automatically 载入页面时，是否自动播放</div><div class="line">        animationDuration: 600, //Integer: S动画淡入淡出效果延时</div><div class="line">        directionNav: true, //Boolean:  (true/false)是否显示左右控制按钮</div><div class="line">        controlNav: true, //Boolean:  usage是否显示控制菜单//什么是控制菜单？</div><div class="line">        keyboardNav: true, //Boolean:left/right keys键盘左右方向键控制图片滑动</div><div class="line">        mousewheel: false, //Boolean: mousewheel鼠标滚轮控制制图片滑动</div><div class="line">        prevText: &quot;Previous&quot;, //String: 上一项的文字</div><div class="line">        nextText: &quot;Next&quot;, //String: 下一项的文字</div><div class="line">        pauseText: &apos;Pause&apos;, //String: 暂停文字</div><div class="line">        playText: &apos;Play&apos;, //String: 播放文字</div><div class="line">        randomize: false, //Boolean: Randomize slide order 是否随机幻灯片</div><div class="line">        slideToStart: 0, //Integer:  (0 = first slide)初始化第一次显示图片位置</div><div class="line">        animationLoop: true, //  &quot;disable&quot; classes at either end 是否循环滚动 循环播放</div><div class="line">        pauseOnAction: true, //Boolean:  highly recommended.</div><div class="line">        pauseOnHover: false, //Boolean: ng</div><div class="line">        controlsContainer: &quot;&quot;, //Selector:  be taken.</div><div class="line">        manualControls: &quot;.js-slidernav i&quot;, //Selector: .自定义控制导航// 小圆点活数字标示 css 选择器        </div><div class="line">        manualControlEvent: &quot;&quot;, //String:自定义导航控制触发事件:默认是click,可以设定hover</div><div class="line">        start: function() &#123;&#125;, //Callback: function(slider) - Fires when the slider loads the first slide</div><div class="line">        before: function() &#123;&#125;, //Callback: function(slider) - Fires asynchronously with each slider animation</div><div class="line">        after: function() &#123;&#125;, //Callback: function(slider) - Fires after each slider animation completes</div><div class="line">        end: function() &#123;&#125; //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>具体项目查看代码<br><a href="https://github.com/twang211/webdemo/tree/master/banner" target="_blank" rel="external">https://github.com/twang211/webdemo/tree/master/banner</a></p>
]]></content>
      
        <categories>
            
            <category> 插件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jq validate 验证优化]]></title>
      <url>/2017/07/11/jq-validate-%E9%AA%8C%E8%AF%81%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>之前使用validate比较简单，并没有做非常大的优化，现在整理了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</div><div class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;jquery表单验证&lt;/title&gt;</div><div class="line">    &lt;script src=&quot;js/jquery-1.4.1-vsdoc.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;js/jquery.validate.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;link href=&quot;css/index.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        $(function () &#123;</div><div class="line">            $(&quot;#FormTo&quot;).validate(&#123;</div><div class="line">                rules: &#123;</div><div class="line">                    uname: &quot;required&quot;,</div><div class="line">                    pwd: &#123;</div><div class="line">                        required: true,</div><div class="line">                        rangelength: [4, 20]</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                messages: &#123;</div><div class="line">                    uname: &quot;用户名不能为空&quot;,</div><div class="line">                    pwd: &#123;</div><div class="line">                        required: &quot;密码不能为空！&quot;,</div><div class="line">                        rangelength: &quot;密码最少4个字符，最多20个字符！&quot;</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                submitHandler: function (form) &#123;</div><div class="line">                    $(form).ajaxSubmit(&#123;</div><div class="line">                        url: $(form).attr(&quot;action&quot;),</div><div class="line">                        type: &apos;post&apos;,</div><div class="line">                        dataType: &apos;json&apos;,</div><div class="line">                        success: function (data) &#123;</div><div class="line">                            if (data.success) &#123;</div><div class="line">                                alert(data.msg);</div><div class="line">                              window.location.href = &quot;Default.aspx&quot;;</div><div class="line">                            &#125; else &#123;</div><div class="line">                                alert(&quot;出现未知错误&quot;);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;,</div><div class="line">                highlight: function (element, errorClass, validClass) &#123; //element出错时触发</div><div class="line">                    $(element).addClass(&quot;inputerror&quot;).next().next().show();</div><div class="line">                &#125;,</div><div class="line">                unhighlight: function (element, errorClass, validClass) &#123; //通过的元素加样式  </div><div class="line">                    $(element).removeClass(&quot;inputerror&quot;).next().html(&quot;通过&quot;).next().hide()</div><div class="line">                &#125;,</div><div class="line">                debug: true,</div><div class="line">                errorClass: &quot;error&quot;,</div><div class="line">                errorElement: &quot;span&quot;,</div><div class="line">                success: &quot;correct&quot;</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;div class=&quot;wrapper&quot;&gt;</div><div class="line">&lt;div class=&quot;titleUI&quot;&gt; &lt;h3&gt;用户注册资料&lt;/h3&gt;&lt;/div&gt;</div><div class="line"> </div><div class="line">&lt;form id=&quot;FormTo&quot; class=&quot;democss&quot; action=&quot;FormRequest.ashx&quot; method=&quot;post&quot;&gt;</div><div class="line">　　&lt;fieldset&gt;&lt;legend&gt;用户注册表单&lt;/legend&gt;</div><div class="line">&lt;div class=&quot;formUI&quot;&gt;</div><div class="line">&lt;p&gt;</div><div class="line">&lt;label for=&quot;name&quot;&gt;用户名:&lt;/label&gt;&lt;input type=&quot;text&quot; class=&quot;inputclass w100&quot; id=&quot;uname&quot; name=&quot;uname&quot; /&gt;&lt;span class=&quot;msg&quot;&gt;用户名必须填写&lt;/span&gt;</div><div class="line">&lt;/p&gt;</div><div class="line"> </div><div class="line">&lt;p&gt;</div><div class="line">&lt;label for=&quot;name&quot;&gt;密码:&lt;/label&gt;&lt;input type=&quot;password&quot; class=&quot;inputclass w200&quot; name=&quot;pwd&quot; /&gt;&lt;span class=&quot;msg&quot;&gt;密码4-20个字符之间&lt;/span&gt;</div><div class="line">&lt;/p&gt;</div><div class="line"> </div><div class="line">&lt;p&gt;</div><div class="line">&lt;label for=&quot;name&quot;&gt;确认密码:&lt;/label&gt;&lt;input type=&quot;password&quot; class=&quot;inputclass w200&quot; name=&quot;pwdTo&quot;  /&gt;&lt;span class=&quot;msg&quot;&gt;密码4-20个字符之dfsafdasdfasdfsaf间&lt;/span&gt;</div><div class="line">&lt;/p&gt;</div><div class="line"> </div><div class="line">&lt;p&gt;</div><div class="line">&lt;label for=&quot;name&quot;&gt;真实姓名:&lt;/label&gt;&lt;input type=&quot;text&quot; class=&quot;inputclass w200&quot; name=&quot;realname&quot;  /&gt;&lt;span class=&quot;msg&quot;&gt;真实姓名必须为字母或汉字 可空&lt;/span&gt;</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">&lt;label for=&quot;name&quot;&gt;新闻内容:&lt;/label&gt;&lt;textarea rows=&quot;5&quot; cols=&quot;5&quot; name=&quot;content&quot; class=&quot;textareaclass w500&quot;&gt;&lt;/textarea&gt;</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">&lt;label for=&quot;name&quot;&gt;是否推荐:&lt;/label&gt;推荐：&lt;input type=&quot;checkbox&quot; name=&quot;Top&quot; value=&quot;0&quot; /&gt; 特价：&lt;input type=&quot;checkbox&quot; name=&quot;Top&quot; value=&quot;1&quot; /&gt; 新品：&lt;input type=&quot;checkbox&quot; name=&quot;Top&quot; value=&quot;2&quot; /&gt;</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;p&gt;</div><div class="line">&lt;label for=&quot;name&quot;&gt;产品分类:&lt;/label&gt;&lt;select name=&quot;category&quot; class=&quot;selectUI&quot; &gt;</div><div class="line">&lt;option value=&quot;1&quot;&gt;我们的产品&lt;/option&gt;</div><div class="line">&lt;option  value=&quot;3&quot;&gt;客户的产品&lt;/option&gt;</div><div class="line">&lt;option  value=&quot;2&quot;&gt;他们的产品&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div><div class="line">&lt;/p&gt;</div><div class="line"> </div><div class="line">&lt;p&gt;</div><div class="line">&lt;label for=&quot;name&quot;&gt; &lt;/label&gt;&lt;input type=&quot;submit&quot; class=&quot;submitClass&quot; value=&quot;添加&quot; /&gt;</div><div class="line">&lt;/p&gt;</div><div class="line"> </div><div class="line">&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/fieldset&gt;</div><div class="line">　　&lt;/form&gt;</div><div class="line">&lt;div id=&quot;messageBox&quot;&gt; &lt;/div&gt;</div><div class="line"> </div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>项目详细介绍地址<br><a href="https://github.com/twang211/webdemo/tree/master/jqueryvalidate%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E6%A1%86%E6%9E%B6" target="_blank" rel="external">https://github.com/twang211/webdemo/tree/master/jqueryvalidate%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E6%A1%86%E6%9E%B6</a></p>
]]></content>
      
        <categories>
            
            <category> 插件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机插件]]></title>
      <url>/2017/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>一款不错的计算机插件<br>代码地址如下：<br><a href="https://github.com/twang211/webdemo/tree/master/jisuanji" target="_blank" rel="external">https://github.com/twang211/webdemo/tree/master/jisuanji</a></p>
]]></content>
      
        <categories>
            
            <category> 插件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript的那些书]]></title>
      <url>/2017/07/08/JavaScript%E7%9A%84%E9%82%A3%E4%BA%9B%E4%B9%A6/</url>
      <content type="html"><![CDATA[<p>第一批次:入门级 ，也适合想掌握一些前端技能的非前端工程师。</p>
<p>《JavaScript DOM 编程艺术》</p>
<p>第二批次:成为一名合格的前端工程师</p>
<p>《JavaScript高级程序设计》(或《JavaScript权威指南》)</p>
<p>《精通JavaScript》</p>
<p>第三批次:更优秀的代码 ，更优良的设计</p>
<p>《JavaScript语言精粹》</p>
<p>《JavaScript设计模式》</p>
<p>第四批次:从语言细节到复杂工程实践 ，想开发靠谱的各类底层代码 ，应该看看</p>
<p>《Secrets of the JavaScript Ninja》</p>
<p>《JavaScript Patterns》</p>
<p>《ECMA-262 in Detail》</p>
<p>应该重视跟踪阅读一些大牛们的Blog了（伯乐在线编注：这篇文章《你得学JavaScript》中有推荐两位大牛的博客，Douglas Crick的博客 和 Angus Croll的JavaScript博客。）</p>
<p>一直在等待：一本JavaScript语言作者或引擎实现者写的书。</p>
<p>番外篇：各类专题书籍 ，读好第二批次书籍之后 ，有精力就接触下</p>
<p>《高性能网站建设指南》</p>
<p>《高性能网站建设进阶指南》</p>
<p>《高性能JavaScript》</p>
<p>《Ajax实战》</p>
<p>《jQuery实战》</p>
<p>《精通CSS》(或《CSS权威指南》)</p>
<p>《正则表达式必知必会》(或《正则表达式权威指南》)</p>
<p>应该选择：一本HTML5方面的书</p>
<p>应该选择：一本NodeJS方面的书</p>
<p>《JavaScript DOM 编程艺术》</p>
<p>话说这本书的中文标题有一些标题党的 ，当初如果知道这仅是一本入门书籍 ，我是不会买来的。拿到后一天就看完了 ，对我来说没有太多技能上的实质帮助。不过这个书语言很流畅 ，重要的是对知识深浅度把握的很好 ，html/js/css/dom各个方面都把握在一个合适的度 ，这很符合我对书籍期望 ，一步步走 ，每一步都踏踏实实。</p>
<p>这本书通过几个实例 ，循序渐进的介绍了前端开发的方方面面 ，让大家能够了解前端的技术体系概况 ，又能具备了一些简单的动手能力。如果大家对我之前写过的浏览器端技术体系概览 — 前端开发的七种武器有些感觉 ，那读读这本书正好能上手实践一把。</p>
<p>去年淘宝前端懒懒交流会的豆瓣小站上做了一个调查 ，如果非要您推荐一本适合新人学习的js方面的书，您的推荐是什么?虽然投票的人不多 ，但这本书却是遥遥领先。</p>
<p>《JavaScript高级程序设计》</p>
<p>这本书的第一版很全面且不枯燥的书籍 ，年纪轻轻的NCZ有这样的大作难能可贵。读懂这本书 ，前端技能又可以上一个台阶 ，基本上可以成为专业的前端工程师了。</p>
<p>对于当时的我来讲 ，这本书及时的补充了浏览器兼容性方面的知识 ，特别是事件相关的知识 ，这个浏览器间差别最大。有些内容讲的非常简单明了 ，比如call和apply的用法 ，之前总是理解不好 ，NCZ几句话+一个例子就说明白了。</p>
<p>然而作为全面型的书籍 ，第一版也是有一些问题的:</p>
<ol>
<li><p>闭包只半页篇幅 ，没说清楚。</p>
</li>
<li><p>匿名函数没怎么讲。</p>
</li>
<li><p>全书没提到constructor ，更别说hasOwnProperty ，<strong>proto</strong>。</p>
</li>
</ol>
<p>这带来了我之前说的深一脚浅一脚的困扰 ，这些知识基本上是通过《JavaScript权威指南》阅读中补充的 ，当然当时版本的权威指南也有同样的问题 ，比如它没解释instanceof。也没提到<strong>proto</strong>。这造成了我对面向对象理解的不全面 ，当时在做了N多测试后还很蛋疼的写了一篇博文<javascript constructor和instanceof,jsoo中的一对欢喜冤家=""> ，后来接触到《JavaScript设计模式》关于OO的全面论述之后 ，果断删掉了这篇JY。</javascript></p>
<p>相信这本书的第二版 ，以及权威指南的第六版肯定会在这些方面进行补充。不过这两本书都是十足的大部头 ，高级程序设计第二版已经比权威指南去除附录要厚了。</p>
<p>一本全面且不枯燥的书太难找了 ，所以我还是喜欢第一版。对我技术上的提升帮助非常之大。忍不住再秀一张图(当时在封闭开发Alimama。com ，马云时常来 ，他不肯在书的第一页签名搞得好像他写的 ，于是把签名画在了第二页。)</p>
<p>《精通JavaScript》</p>
<p>我会把书籍分成两类 ，一类是全面型 ，一类是犀利型。前面介绍了一本全面型的书籍 ，接下来介绍的这本的特点是非常犀利 ，这类书籍的特点是作者能找对重点(2/8原则掌握的很好) ，在重点位置深入挖掘。这本书的作者John Resig也是jQuery的作者 ，他显然是个足够犀利的人儿。</p>
<p>jQuery从未承诺解决所有问题 ，但再一些重点部位的突破 ，让这个类库如此流行。这本书并没有着重介绍jQuery ，还是基于原生的JavaScript和DOM API。</p>
<p>列一些这本书的重点话题 ，能够很好的看出作者为什么会开发出jQuery ，或者说jQuery为什么是现在的样子:</p>
<ol>
<li><p>如何创建可复用的代码?如何调试 ，测试?(这是基础)</p>
</li>
<li><p>如何判断DOM何时加载完毕?如何遍历 ，修改DOM?(jQuery以DOM为核心 ，节点的增删改查 ，事件响应是重点)</p>
</li>
<li><p>如何确定元素的位置 ，相对于页面/屏幕?如何做平滑的动画?(思考下CSS相关的话题很多 ，作者为什么选了这两个?)</p>
</li>
<li><p>如何改进表单验证 ，封装完整的Ajax程序?(涉及数据交互 ，是另一个重中之重。)</p>
</li>
</ol>
<p>不算厚的一本书 ，基本上就是以上的话题+几个实例。当我们看过了一本全面型的书籍 ，对前端的知识有了深入的了解之后 ，这本书的作者指出了今后的重点 ，并告诉大家如何把知识用到解决重点问题上。</p>
<p>《JavaScript语言精粹》</p>
<p>推荐大家看看阮一峰老师的博文《JavaScript诞生记》，JavaScript是Brendan Eich大神10天时间设计出的语言 ，现在成了Web前端领域的唯一语言。</p>
<p>一方面这门语言博采众家之长 ，也帮助它维系了长久的生命力:</p>
<p>“1. 借鉴C语言的基本语法；</p>
<ol>
<li><p>借鉴Java语言的数据类型和内存管理；</p>
</li>
<li><p>借鉴Scheme语言，将函数提升到”第一等公民”（first class）的地位；</p>
</li>
<li><p>借鉴Self语言，使用基于原型（prototype）的继承机制。”</p>
</li>
</ol>
<p>另一方面”由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。”Brendan Eich对其这10天工作的评价是:”它的优秀之处并非原创，它的原创之处并不优秀。”</p>
<p>Douglas Crockford通过《JavaScript: The Good Parts》这本书对JavaScript进行了一次大审判 ，老道认为JavaScript语言有很多优秀的地方 ，也有一些鸡肋和糟粕。老道不反对用这门语言 ，在规避一些鸡肋和糟粕之后它自然是优秀的。<br>老道认为JavaScript优美的特性如下:</p>
<ol>
<li><p>函数是头等对象(可以作为其他函数的参数和返回值 ，支持闭包)</p>
</li>
<li><p>基于原型继承的动态对象</p>
</li>
<li><p>对象字面量和数组字面量(构成JSON的基础)</p>
</li>
</ol>
<p>老道列出了很多鸡肋和糟粕 ，并提供了JSLint这个工具 ，来校验代码是否使用了不好的部分。书中给出的语法图让我有深入学习一下&lt;编译原理&gt;的冲动 ，也理解了JSLint作为用JS语言分析JS语言的工具成型的理论基础。</p>
<p>强烈建议大家使用JSLint来检测自己的代码 ，但是我们不必教条 ，可以违返其中一些的检测规则 ，只要我们清楚老道为什么会设置这个规则 ，有什么风险?若我们不遵守这个规则 ，是否能回避相应的风险。</p>
<p>我觉得这本书最重要的意义是告诉我们为什么”它是鸡肋 ，它是糟粕”这是经过前面的学习和大量实践之后 ，成熟的开发者应该关注的。比如:</p>
<ol>
<li><p>hasOwnProperty ，老道说它糟粕的原因是因为这不是一个关键字 ，而是一个Object。prototype上可以被重写的方法。那么这个告诉我们 ，并不是不要用hasOwnProperty ，而是要注意不要覆盖它。</p>
</li>
<li><p>eval的主要问题是性能 ，大量的eval(类eval)语句降低了JS引擎的性能。而经过测试少量的eval语句+eval大段的JS文本性能并不差 ，有必要也可以考虑使用。</p>
</li>
</ol>
<p>《JavaScript设计模式》</p>
<p>这是一本介绍JavaScript面向对象编程以及设计模式非常好的书籍。相对于又一本全面型书籍语言精粹 ，犀利型书籍登场了。我对面向对象的看法是：隐藏细节 ，方便做大。基于良好的抽象和封装 ，我们可以方便的自顶而下的设计 ，自底而上的开发。面向对象的优缺点不是本文的重点 ，这里不讨论 ，只能说这是一个非常不错的代码设计实现方法论。</p>
<p>JavaScript到底是不是一个面向对象的语言 ，从本质说一定是的 ，从表象来说OO的不那么明显。我们必须通过一些额外的代码实现诸如 ，划分公有/私有 ，接口 ，继承 ，多态等特性。由于JavaScript语言的灵活性 ，实现的方式非常多。这本书的第一部分对常见的两类实现模式:类式继承和原型继承都有非常好的最佳实践总结。所以我的想法是完全读懂它 ，然后按照这个来做就好了。如果这里介绍的实践足够强大 ，我们没有必要发明新的继承实现模式了 ，事实上YUI一直是这种模式 ，而新的JavaScript引擎甚至引入了Object。create方法 ，将一些动作写入标准内置在JS引擎中。</p>
<p>我们应该将视点放在设计模式上 ，GoF的设计模式那本书里的例子 ，对于前端开发来说并不都是很好理解 ，而这本书的例子全部是前端相关 ，有助于大家理解设计模式的精妙。还有些同学说 ，即使我不了解GoF的理论 ，我也在默默的用这些模式了。确实是这样 ，但我想我们关注设计模式 ，不光要学会各种模式是怎样的 ，更重要的是学习到各种模式适合什么场合 ，不适合什么场合。了解有什么优点 ，也要了解有什么缺点 ，你正在默默使用的模式存在隐患么?系统学习之后会对其更有把握。</p>
<p>前几天听同事说这本书全面断货 ，不知道是太火 ，还是印的太少 ，希望能尽快看到上架。</p>
<p>Secrets of the JavaScript Ninja</p>
<p>进入第四个批次 ，这里的书籍多数没有中译本出版。现阶段想开发靠谱的底层类库代码 ，确实需要啃一些外文书了。英文书很多 ，没有精力大量阅读 ，通常读一些口碑较好的书籍。</p>
<p>另外 ，到了这个批次 ，我的阅读量也相当的有限 ，所以肯定有很多好的内容没有提到 ，期望大家能继续推荐。而且到了这个批次 ，书籍产出肯定跟不上知识的更新速度 ，跟踪阅读一些JS大牛们的Blog应该成为习惯。<br>这是jQuery作者的第二本书 ，自然优势犀利型的代表。John Resig已经陆续放出这本书的大部分内容 ，从2008年开始写 ，计划2012年5月出版。</p>
<p>如果说JR的第一本书能够看出为什么有jQuery ，那么这本书能看出让jQuery发展下去 ，作者关注了哪些。我们会看到其实一些很细节的内容 ，比如强调测试用例的构建/自动化测试的方法 ，比如如何利用每个function实例的length属性 ，比如对with ，eval的思考和发散等等。</p>
<p>关于这本书具体如何的好处 ，我还理不清 ，拿来开开眼界是非常不错的。记得玉伯大大组织了一波同学在翻译 ，不知进展如何了。</p>
<p>《JavaScript Patterns》</p>
<p>乍一看这本书标题 ，以为又是一本讲设计模式的书 ，那和《JavaScript设计模式》重复了 ，开始没有仔细关注。今年拔赤推荐了它 ，才发现者并不仅仅介绍GoF的设计模式而是涵盖前端开发各个方面的先进理论。虽然是09年的书，这两年前端的很多较深刻变化在这边书里都能看到雏形。上一本书犀利，这本更全面。</p>
<p>作者Stoyan Stefanov是Yahoo的前端技术专家 ，从这本书中可以看到很多YUI3设计上的本源 ，比如在对象创建模式中介绍的模块模式/沙箱模式。近来CommonJS Loader的流行在这之上的继续深入发掘。这本书还包括代码测试 ，打包 ，部署 ，加载策略等各个流程中的诸多细节 ，这些构成了完整的体系在Yahoo在YUI3都有非常好的实践。</p>
<p>听说我们的同事拔赤和一舟在翻译这个本书 ，非常期待。</p>
<p>ECMA-262</p>
<p>这不是一本书 ，是俄罗斯小伙子写的一系列ECMA-262标准分析文章 ，ECMA-262-3系列已经很完整。标准像汇编语言一样枯燥 ，而这系列文章把枯燥的标准转化为一系列深入讨论的话题 ，配合恰到好处的示例 ，一定会让大家对JS引擎的认识再上一层。</p>
<p>网上有一些译文 ，但是由于类似文章译文比较少 ，很多英文还未达成一致表述 ，所以推荐阅读英原文。另外作者很好 ，遇到的棘手的问题 ，去咨询他都能很快收到很好的回复。</p>
<p>期待:一本JavaScript语言作者或引擎实现者写的书</p>
<p>一直以来期待JavaScript能有一本像《C程序设计语言》这样的大作，最近也在读计算机系统概论补一些大学时没学好的知识 ，非常认同书中”自底而上”的学习路线。我想对JavaScript引擎的透彻分析 ，能够减少大家看着实验结果 ，猜测着写书的境况。随着NodeJS的火爆 ，引擎的技术分析文章越来越多 ，期待很快出现集大成者。</p>
<p>《高性能网站建设指南》《高性能网站建设进阶指南》《高性能JavaScript》</p>
<p>进入番外篇 ，推荐的书籍都是有针对性的领域之作 ，内容往往并不高深 ，大家根据自己的实际情况进行选择阅读。</p>
<p>高性能的网页是前端必然的追求 ，Steve Sounders率先在Yahoo开启了这方面的专题研究 ，伴随着《高性能网站建设指南》的出版和YSlow工具发布。网站性能优化 ，特别是前端角度和运维角度的优化方案 ，进入了人们的视野 ，同时获得了巨大的效果 ，甚至形成了名为WPO(Web Performance Optimization)产业。</p>
<p>第一本书除了介绍了能够立竿见影的规则的同时也开启了民智。大家开始思考如何做优化 ，如何结合自己的应用实践做优化。而后两本书基本上是遵循优化思路的继续得来的实践总结。关于优化的工具,思路，方法是我特别强调的。感兴趣的同学可以看下在Yslow 34 Rules之后 — 网站性能优化思路和进展 这一篇。</p>
<p>其他领域之作</p>
<p>接下来介绍这些专题类书籍 ，并不是特别推荐 ，往往每个专题都有很多书籍可供选择 ，随手写一些读书心得吧。</p>
<p>《Ajax实战》：06年的书，很早就购入。书中介绍了很多RIA高级应用的相关话题,很开眼界。</p>
<p>《jQuery实战》：一定需要一本介绍jQuery的书，这书还可以，不过现在看来应该比较旧了,jQuery已经更新了很多。我主要从这本书了解了jQuery的工具函数扩展机制和插件机制是如何实现的。jQuery让完全不了解prototype属性的同学也能写出可复用的复杂组件，非常不容易，以后再单独写写对jQuery的一些看法吧。</p>
<p>《精通CSS》：一定需要一本介绍CSS的书，工作中一直以来CSS用的不是很深入,不做特殊介绍.</p>
<p>《正则表达式必知必会》：一定需要一本正则方面的书籍，这本小册子查起来蛮方便.</p>
<p>《HTML5揭秘》和《HTML5高级程序设计》买回来一直没看，对HTML5的新增特性还是有了解的,等能用到时再看再评。</p>
<p>希望看到NodeJS方面的书籍 ，尽快引入。</p>
<p>写在最后</p>
<p>我只能推荐我看过的书对吧 ，所以大家懂的。我们不去对比各种电子产品 ，就是对比鸡蛋大米 ，书籍都是非常廉价的。</p>
<p>当有了领域内一定的实践经验之后 ，阅读一本相关的书籍并不是难事 ，也并不会耗费很多时间。</p>
<p>全面型的书籍可以让大家技能水平一步一步地稳步提高 ，让大家站得高也站得稳。</p>
<p>犀利型的书籍可以让大家了解重点 ，了解别人是怎么运用那些你也会的知识的。</p>
<p>专题类的书籍是拓宽眼界 ，帮助大家完成工作任务的好手。</p>
<p>对于非英文专业的同学 ，如果有中译本 ，不用非得纠结着去看原版 ，我们要最快学到知识 ，最快进入思考与实践。</p>
<p>感谢作者 ，译者(我的同事中有很多译者 ，都说指望这个赚钱是不可能的) ，以及选择运作这些书出版的各位老师。</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
            <tag> js </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mongoDB分享]]></title>
      <url>/2017/07/08/mongoDB%E5%88%86%E4%BA%AB/</url>
      <content type="html"><![CDATA[<p>1 ) . 大于，小于，大于或等于，小于或等于</p>
<p>$gt:大于<br>$lt:小于<br>$gte:大于或等于<br>$lte:小于或等于</p>
<p>例子：</p>
<p>db.collection.find({ “field” : { $gt: value } } ); // greater than : field &gt; value<br>db.collection.find({ “field” : { $lt: value } } ); // less than : field &lt; value<br>db.collection.find({ “field” : { $gte: value } } ); // greater than or equal to : field &gt;= value<br>db.collection.find({ “field” : { $lte: value } } ); // less than or equal to : field &lt;= value如查询j大于3,小于4:<br>db.things.find({j : {$lt: 3}});<br>db.things.find({j : {$gte: 4}});也可以合并在一条语句内:<br>db.collection.find({ “field” : { $gt: value1, $lt: value2 } } ); // value1 &lt; field &lt; value</p>
<p>2) 不等于 $ne<br>例子：<br>db.things.find( { x : { $ne : 3 } } );</p>
<p>3) in 和 not in ($in $nin)</p>
<p>语法：<br>db.collection.find( { “field” : { $in : array } } );例子：<br>db.things.find({j:{$in: [2,4,6]}});<br>db.things.find({j:{$nin: [2,4,6]}});</p>
<p>4) 取模运算$mod</p>
<p>如下面的运算：<br>db.things.find( “this.a % 10 == 1”)可用$mod代替：<br>db.things.find( { a : { $mod : [ 10 , 1 ] } } )</p>
<p>5)  $all</p>
<p>$all和$in类似，但是他需要匹配条件内所有的值：</p>
<p>如有一个对象：</p>
<p>{ a: [ 1, 2, 3 ] }下面这个条件是可以匹配的：<br>db.things.find( { a: { $all: [ 2, 3 ] } } );但是下面这个条件就不行了：<br>db.things.find( { a: { $all: [ 2, 3, 4 ] } } );</p>
<p>6)  $size</p>
<p>$size是匹配数组内的元素数量的，如有一个对象：{a:[“foo”]}，他只有一个元素：</p>
<p>下面的语句就可以匹配：db.things.find( { a : { $size: 1 } } );官网上说不能用来匹配一个范围内的元素，如果想找$size&lt;5之类的，他们建议创建一个字段来保存元素的数量。<br>You cannot use $size to find a range of sizes (for example: arrays with more than 1 element). If you need to query for a range, create an extra size field that you increment when you add elements.</p>
<p>7）$exists<br>$exists用来判断一个元素是否存在：<br>如：<br>db.things.find( { a : { $exists : true } } ); // 如果存在元素a,就返回<br>db.things.find( { a : { $exists : false } } ); // 如果不存在元素a，就返回</p>
<p>8)  $type</p>
<p>$type 基于 bson type来匹配一个元素的类型，像是按照类型ID来匹配，不过我没找到bson类型和id对照表。<br>db.things.find( { a : { $type : 2 } } ); // matches if a is a string<br>db.things.find( { a : { $type : 16 } } ); // matches if a is an int<br>9）正则表达式</p>
<p>mongo支持正则表达式，如：</p>
<p>db.customers.find( { name : /acme.*corp/i } ); // 后面的i的意思是区分大小写</p>
<p>10)  查询数据内的值</p>
<p>下面的查询是查询colors内red的记录，如果colors元素是一个数据,数据库将遍历这个数组的元素来查询。db.things.find( { colors : “red” } );</p>
<p>11) $elemMatch</p>
<p>如果对象有一个元素是数组，那么$elemMatch可以匹配内数组内的元素：</p>
<blockquote>
<p>t.find( { x : { $elemMatch : { a : 1, b : { $gt : 1 } } } } )<br>{ “_id” : ObjectId(“4b5783300334000000000aa9”),<br>“x” : [ { “a” : 1, “b” : 3 }, 7, { “b” : 99 }, { “a” : 11 } ]<br>}$elemMatch : { a : 1, b : { $gt : 1 } } 所有的条件都要匹配上才行。注意，上面的语句和下面是不一样的。<br>t.find( { “x.a” : 1, “x.b” : { $gt : 1 } } )<br>$elemMatch是匹配{ “a” : 1, “b” : 3 }，而后面一句是匹配{ “b” : 99 }, { “a” : 11 } </p>
</blockquote>
<p>12)  查询嵌入对象的值</p>
<p>db.postings.find( { “author.name” : “joe” } );注意用法是author.name，用一个点就行了。更详细的可以看这个链接： dot notation<br>举个例子：</p>
<blockquote>
<p>db.blog.save({ title : “My First Post”, author: {name : “Jane”, id : 1}})如果我们要查询 authors name 是Jane的, 我们可以这样：<br>db.blog.findOne({“author.name” : “Jane”})如果不用点，那就需要用下面这句才能匹配：<br>db.blog.findOne({“author” : {“name” : “Jane”, “id” : 1}})下面这句：<br>db.blog.findOne({“author” : {“name” : “Jane”}})是不能匹配的，因为mongodb对于子对象，他是精确匹配。</p>
</blockquote>
<p>13) 元操作符 $not 取反<br>如：<br>db.customers.find( { name : { $not : /acme.*corp/i } } );db.things.find( { a : { $not : { $mod : [ 10 , 1 ] } } } ); </p>
]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mongodb </tag>
            
            <tag> nosql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js优化]]></title>
      <url>/2017/07/08/js%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>方法一：把不重要的JS放在页面最底部<br>这是最简单，也是效果最好的优化方法，把不重要的JS通通放到页面的最下面body的上面，实现异步加载，也就是等网页都加载完了，最后在加载这些不重要的JS，这样就不影响网页速度了。<br>方法二：合并JS文件<br>合并JS，也就是减少HTTP请求，少给服务器请求一次就加快一点速度，而合并两个原本独立的JS就需要点技术了，但这难不倒我们，告诉大家一个最简单的方法：<br>不管三七二十一，先把A文件直接粘贴到B文件中，合并后删除网页中的A文件，如果网页运行正常，就OK；如果一些特效失效，那就还原，换C文件合并。总会有两个不冲突的JS文件的。<br>方法三：给JS文件减肥<br>咱不讨论什么三目运算符、减少对象查找、如何让JS简洁，咱就用“JS减肥工具”。通常这类工具会把JS文件中几百行的代码压缩成一行，使体积变小。推荐工具：<a href="http://javascriptcompressor.com/" target="_blank" rel="external">http://javascriptcompressor.com/</a><br>因为空行等问题，有时候使用这类工具会使JS功能失效，而最简单的办法是用Dreamweaver，把压缩后的JS放入DW中，DW会自动提示你那里有误，把错误的地方另起一行，或还原回去即可。</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
            <tag> js </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js兼容问题注意事项]]></title>
      <url>/2017/07/08/js%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<p>//window.event<br>IE：有window.event对象<br>FF：没有window.event对象。可以通过给函数的参数传递event对象。如onmousemove=doMouseMove(event)   </p>
<p>//鼠标当前坐标<br>IE：event.x和event.y。<br>FF：event.pageX和event.pageY。<br>通用：两者都有event.clientX和event.clientY属性。   </p>
<p>//鼠标当前坐标(加上滚动条滚过的距离)<br>IE：event.offsetX和event.offsetY。<br>FF：event.layerX和event.layerY。   </p>
<p>//event.srcElement问题<br>说明:IE下,event对象有srcElement属性,但是没有target属性;Firefox下,event对象有target属性,但是没有srcElement属性.<br>解决方法:使用obj(obj = event.srcElement ? event.srcElement : event.target;)来代替IE下的event.srcElement或者Firefox下的event.target. 请同时注意event的兼容性问题。  </p>
<p>//event.toElement问题<br>问题：<br>IE下，event对象有srcElement属性，但是没有target属性；Firefox下，event对象有target属性，但是没有srcElement属性<br>解决方法：<br>var target = e.relatedTarget || e.toElement;   </p>
<p>//标签的x和y的坐标位置：style.posLeft 和 style.posTop<br>IE：有。<br>FF：没有。<br>通用：object.offsetLeft 和 object.offsetTop。   </p>
<p>//窗体的高度和宽度<br>IE：document.body.offsetWidth和document.body.offsetHeight。注意：此时页面一定要有body标签。<br>FF：window.innerWidth和window.innerHegiht，以及document.documentElement.clientWidth和document.documentElement.clientHeight。<br>通用：document.body.clientWidth和document.body.clientHeight。   </p>
<p>//添加事件<br>IE：element.attachEvent(“onclick”, function);。<br>FF：element.addEventListener(“click”, function, true)。<br>通 用：element.onclick=function。虽然都可以使用onclick事件，但是onclick和上面两种方法的效果是不一样的，onclick 只有执行一个过程，而attachEvent和addEventListener执行的是一个过程列表，也就是多个过程。例如：element.attachEvent(“onclick”, func1);element.attachEvent(“onclick”, func2)这样func1和func2都会被执行。   </p>
<p>//标签的自定义属性<br>IE：如果给标签div1定义了一个属性value，可以div1.value和div1[“value”]取得该值。<br>FF：不能用div1.value和div1[“value”]取。<br>通用：div1.getAttribute(“value”)。   </p>
<p>//document.form.item 问题<br>IE:现有问题：现有代码中存在许多 document.formName.item(“itemName”) 这样的语句，不能在 MF 下运行<br>FF/IE: document.formName.elements[“elementName”]  </p>
<p>//集合/数组类对象问题<br>(1)现有问题：<br>    现有代码中许多集合类对象取用时使用 ()，IE 能接受，MF 不能。<br>(2)解决方法：<br>    改用 [] 作为下标运算。如：document.forms(“formName”) 改为 document.forms[“formName”]。<br>    又如：document.getElementsByName(“inputName”)(1) 改为 document.getElementsByName(“inputName”)[1]  </p>
<p>//HTML 对象的 id 作为对象名的问题<br>(1)现有问题<br>     在 IE 中，HTML 对象的 ID 可以作为 document 的下属对象变量名直接使用。在 MF 中不能。<br>(2)解决方法<br>     用 getElementById(“idName”) 代替 idName 作为对象变量使用  </p>
<p>//用idName字符串取得对象的问题<br>(1)现有问题<br>     在IE中，利用 eval(idName) 可以取得 id 为 idName 的 HTML 对象，在MF 中不能。<br>(2)解决方法<br>     用 getElementById(idName) 代替 eval(idName)。  </p>
<p>//变量名与某 HTML 对象 id 相同的问题<br>(1)现有问题<br>    在 MF 中，因为对象 id 不作为 HTML 对象的名称，所以可以使用与 HTML 对象 id 相同的变量名，IE 中不能。<br>(2)解决方法<br>    在声明变量时，一律加上 var ，以避免歧义，这样在 IE 中亦可正常运行。<br>    此外，最好不要取与 HTML 对象 id 相同的变量名，以减少错误。  </p>
<p>//document.getElementsByName() 和 document.all[name] 的问题<br>现有问题：在 IE 中，getElementsByName()、document.all[name] 均不能用来取得 div 元素（是否还有其它不能取的元素还不知道）。<br>//document.all<br>Firefox可以兼容document.all， 但会生成一条警告。可以用getElementById(“<em>“) 或者 getElementByTagName(“</em>“)来代替<br>不过对于document.all.length等属性，则完全不兼容  </p>
<p>//input.type属性问题<br>说明:IE下input.type属性为只读;但是Firefox下input.type属性为读写  </p>
<p>//window.location.href问题<br>说明:IE或者Firefox2.0.x下,可以使用window.location或window.location.href;Firefox1.5.x下,只能使用window.location<br>解决方法:使用window.location来代替window.location.href  </p>
<p>//模态和非模态窗口问题<br>说明:IE下,可以通过showModalDialog和showModelessDialog打开模态和非模态窗口;Firefox下则不能<br>解决方法:直接使用window.open(pageURL,name,parameters)方式打开新窗口。<br>如果需要将子窗口中的参数传递回父窗口,可以在子窗口中使用window.opener来访问父窗口. 例如：var parWin = window.opener; parWin.document.getElementById(“Aqing”).value = “Aqing”;   </p>
<p>//frame问题<br>以下面的frame为例：   </p>
<p><frame src="xxx.html" mce_src="xxx.html" id="frameId" name="frameName"><br>(1)访问frame对象:<br>IE:使用window.frameId或者window.frameName来访问这个frame对象. frameId和frameName可以同名。<br>FF:只能使用window.frameName来访问这个frame对象.<br>另外，在IE和Firefox中都可以使用window.document.getElementById(“frameId”)来访问这个frame对象.<br>(2)切换frame内容:<br>在IE和Firefox中都可以使用window.document.getElementById(“testFrame”).src = “xxx.html”或window.frameName.location = “xxx.html”来切换frame的内容.<br>如果需要将frame中的参数传回父窗口(注意不是opener,而是parent frame)，可以在frme中使用parent来访问父窗口。例如：window.parent.document.form1.filename.value=”Aqing”;   </p>
<p>//body问题<br>Firefox的body在body标签没有被浏览器完全读入之前就存在；而IE的body则必须在body标签被浏览器完全读入之后才存在  </p>
<p>//事件委托方法<br>IE：document.body.onload = inject; //Function inject()在这之前已被实现<br>FF：document.body.onload = inject();   </p>
<p>//firefox与IE的父元素(parentElement)的区别<br>IE：obj.parentElement<br>FF：obj.parentNode<br>解决方法: 因为FF与IE都支持DOM,因此使用obj.parentNode是不错选择  </p>
<p>//innerText在IE中能正常工作，但是innerText在FireFox中却不行. 需用textContent  </p>
<p>//FireFox中设置HTML标签的style时，所有位置性和字体尺寸的值必须后跟px。这个ie也是支持的  </p>
<p>//父节点、子节点和删除节点<br>IE：parentElement、parement.children，element.romoveNode(true)。<br>FF：parentNode、parentNode.childNodes，node.parentNode.removeChild(node)。   </p>
<p>//对select的options集合操作<br>枚举元素除了[]外，SelectName.options.item()也是可以的, 另外SelectName.options.length, SelectName.options.add/remove都可以在两种浏览器上使用。<br>注意在add后赋值元素，否则会失败<br>动态删除select中的所有options：<br>       document.getElementById(“ddlResourceType”).options.length=0;<br>动态删除select中的某一项option：<br>       document.getElementById(“ddlResourceType”).options.remove(indx);<br>动态添加select中的项option:<br>       document.getElementById(“ddlResourceType”).options.add(new Option(text,value));<br>IE FF 动态删除通用方法：<br>document.getElementById(“ddlResourceType”).options[indx] = null;  </p>
<p>//捕获事件<br>问题：<br>FF没有setCapture()、releaseCapture()方法<br>解决方法：<br>IE:<br>obj.setCapture();<br>obj.releaseCapture();<br>FF:<br>window.captureEvents(Event.MOUSEMOVE|Event.MOUSEUP);<br>window.releaseEvents(Event.MOUSEMOVE|Event.MOUSEUP);<br>if (!window.captureEvents) {<br>       o.setCapture();<br>}else {<br>       window.captureEvents(Event.MOUSEMOVE|Event.MOUSEUP);<br>}<br>if (!window.captureEvents) {<br>       o.releaseCapture();<br>}else {<br>       window.releaseEvents(Event.MOUSEMOVE|Event.MOUSEUP);<br>}   </p>
<p>//禁止选取网页内容<br>问题：<br>FF需要用CSS禁止，IE用JS禁止<br>解决方法：<br>IE: obj.onselectstart = function() {return false;}<br>FF: -moz-user-select:none;   </p>
<p>//画图<br>IE：VML。<br>FF：SVG。   </p>
<p>//CSS：透明<br>IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。<br>FF：opacity:0.6。   </p>
<p>//CSS：圆角<br>IE：不支持圆角。<br>FF：-moz-border-radius:4px，或者-moz-border-radius-topleft:4px;-moz-border-radius-topright:4px;-moz-border-radius-bottomleft:4px;-moz-border-radius- bottomright:4px;。   </p>
<p>//CSS：双线凹凸边框<br>IE：border:2px outset;。<br>FF：-moz- border-top-colors: #d4d0c8 white;-moz-border-left-colors: #d4d0c8 white;-moz-border-right-colors:#404040 #808080;-moz-border-bottom-colors:#404040 #808080;。  </p>
<p>多多支持！！！！</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
            <tag> js </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript数组去重的几种方法]]></title>
      <url>/2017/07/07/JavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>数组去重复是一个常见的需求，我们暂时考虑同类型的数组去重复。主要是理清思路和考虑下性能。以下方法，网上基本都有，这里只是简单地总结一下。<br>            思路：</p>
<p>遍历数组，一一比较，比较到相同的就删除后面的<br>遍历数组，一一比较，比较到相同的，跳过前面重复的，不相同的放入新数组<br>任取一个数组元素放入新数组，遍历剩下的数组元素任取一个，与新数组的元素一一比较，如果有不同的，放入新数组。<br>遍历数组，取一个元素，作为对象的属性，判断属性是否存在</p>
<ol>
<li>删除后面重复的：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function ov1(arr)&#123;</div><div class="line">    //var a1=((new Date).getTime())</div><div class="line">    for(var i=0;i&lt;arr.length;i++)</div><div class="line">        for(var j=i+1;j&lt;arr.length;j++)</div><div class="line">            if(arr===arr[j])&#123;arr.splice(j,1);j--;&#125;            </div><div class="line">    //console.info((new Date).getTime()-a1)                </div><div class="line">    return arr.sort(function(a,b)&#123;return a-b&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>这个是常规的方法，比较好理解，如果相同则跳出循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function ov2(a) &#123;</div><div class="line">    //var a1=((new Date).getTime())</div><div class="line">    var b = [], n = a.length, i, j;</div><div class="line">    for (i = 0; i &lt; n; i++) &#123;</div><div class="line">        for (j = i + 1; j &lt; n; j++)</div><div class="line">            if (a === a[j])&#123;j=false;break;&#125;</div><div class="line">        if(j)b.push(a);</div><div class="line">        &#125;</div><div class="line">    //console.info((new Date).getTime()-a1)    </div><div class="line">    return b.sort(function(a,b)&#123;return a-b&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这个我花了好长时间明白的，这里j循环虽然继续了，但是i值已经改变了。就等于是一个新的i循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function ov3(a) &#123;</div><div class="line">    //var a1=((new Date).getTime())</div><div class="line">    var b = [], n = a.length, i, j;</div><div class="line">    for (i = 0; i &lt; n; i++) &#123;</div><div class="line">        for (j = i + 1; j &lt; n; j++)</div><div class="line">        if (a === a[j])j=++i</div><div class="line">    b.push(a);&#125;</div><div class="line">    //console.info((new Date).getTime()-a1)    </div><div class="line">    return b.sort(function(a,b)&#123;return a-b&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>保证新数组中的都是唯一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function ov4(ar)&#123;</div><div class="line">//var a1=((new Date).getTime())</div><div class="line">    var m=[],f;</div><div class="line">    for(var i=0;i&lt;ar.length;i++)&#123;</div><div class="line">    f=true; </div><div class="line">    for(var j=0;j&lt;m.length;j++)</div><div class="line">    if(ar===m[j])&#123;f=false;break;&#125;;</div><div class="line">    if(f)m.push(ar)&#125;</div><div class="line">//console.info((new Date).getTime()-a1)    </div><div class="line">    return m.sort(function(a,b)&#123;return a-b&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用对象属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function ov5(ar)&#123;</div><div class="line">//    var a1=(new Date).getTime()</div><div class="line">                var m,n=[],o= &#123;&#125;;</div><div class="line">                for (var i=0;(m= ar)!==undefined;i++)</div><div class="line">                if (!o[m])&#123;n.push(m);o[m]=true;&#125;</div><div class="line">//    console.info((new Date).getTime()-a1)    </div><div class="line">        return n.sort(function(a,b)&#123;return a-b&#125;);;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>本文经过网上查找，如果有问题希望大家能够帮忙指正！</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
            <tag> js </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 数组去重 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 正则表达式]]></title>
      <url>/2017/07/07/python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<ol>
<li>正则表达式基础1.1. 简单介绍<br>正则表达式并不是Python的一部分。正则表达式是用于处 理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能十分强大。得益于这一点，在提供了正则表达式的 语言里，正则表达式的语法都是一样的，区别只在于不同的编程语言实现支持的语法数量不同；但不用担心，不被支持的语法通常是不常用的部分。如果已经在其他 语言里使用过正则表达式，只需要简单看一看就可以上手了。<br>下图展示了使用正则表达式进行匹配的流程：</li>
</ol>
<p>正则表达式的大致匹配过程是：依次拿出表达式和文本中的字符比较，如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。如果表达式中有量词或边界，这个过程会稍微有一些不同，但也是很好理解的，看下图中的示例以及自己多使用几次就能明白。<br>下图列出了Python支持的正则表达式元字符和语法：  </p>
<p>1.2. 数量词的贪婪模式与非贪婪模式<br>正 则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪 的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab<em>“如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量 词”ab</em>?”，将找到”a”。<br>1.3. 反斜杠的困扰<br>与大多数编程语言相同，正则表达式里使用””作为转义 字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符””，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\“：前两个和后两个分 别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，这个例子中的 正则表达式可以使用r”\”表示。同样，匹配一个数字的”\d”可以写成r”d”。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表 达式也更直观。<br>1.4. 匹配模式<br>正则表达式提供了一些可用的匹配模式，比如忽略大小写、多行匹配等，这部分内容将在Pattern类的工厂方法re.compile(pattern[, flags])中一起介绍。</p>
<ol>
<li>re模块2.1. 开始使用re<br>Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># encoding: UTF-8</div><div class="line">import re</div><div class="line"></div><div class="line"># 将正则表达式编译成Pattern对象</div><div class="line">pattern = re.compile(r&apos;hello&apos;)</div><div class="line"></div><div class="line"># 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None</div><div class="line">match = pattern.match(&apos;hello world!&apos;)</div><div class="line"></div><div class="line">if match:</div><div class="line">    # 使用Match获得分组信息</div><div class="line">    print match.group()</div><div class="line"></div><div class="line">### 输出 ###</div><div class="line"># hello</div></pre></td></tr></table></figure>
</li>
</ol>
<p>re.compile(strPattern[, flag]):<br>这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。 第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。<br>可选值有：<br>re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）<br>M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）<br>S(DOTALL): 点任意匹配模式，改变’.’的行为<br>L(LOCALE): 使预定字符类 w W b B s S 取决于当前区域设定<br>U(UNICODE): 使预定字符类 w W b B s S d D 取决于unicode定义的字符属性<br>X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = re.compile(r&quot;&quot;&quot;d +  # the integral part</div><div class="line">                   .    # the decimal point</div><div class="line">                   d *  # some fractional digits&quot;&quot;&quot;, re.X)</div><div class="line">b = re.compile(r&quot;d+.d*&quot;)</div></pre></td></tr></table></figure></p>
<p>re提供了众多模块方法用于完成正则表达式的功能。这些方法可以使用Pattern实例的相应方法替代，唯一的好处是少写一行 re.compile()代码，但同时也无法复用编译后的Pattern对象。这些方法将在Pattern类的实例方法部分一起介绍。如上面这个例子可以 简写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">m = re.match(r&apos;hello&apos;, &apos;hello world!&apos;)</div><div class="line">print m.group()</div></pre></td></tr></table></figure></p>
<p>re模块还提供了一个方法escape(string)，用于将string中的正则表达式元字符如*/+/?等之前加上转义符再返回，在需要大量匹配元字符时有那么一点用。<br>2.2. Match<br>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。<br>属性：<br>string: 匹配时使用的文本。<br>re: 匹配时使用的Pattern对象。<br>pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。<br>endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。<br>lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。<br>lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。<br>方法：<br>group([group1, …]):<br>获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。<br>groups([default]):<br>以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。<br>groupdict([default]):<br>返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。<br>start([group]):<br>返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。<br>end([group]):<br>返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。<br>span([group]):<br>返回(start(group), end(group))。<br>expand(template):<br>将匹配到的分组代入template中然后返回。template中可以使用id或g、 g引用分组，但不能使用编号0。id与g是等价的；但10将被认为是第10个分组，如果你想表达 1之后是字符’0’，只能使用g<1>0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">m = re.match(r&apos;(w+) (w+)(?P.*)&apos;, &apos;hello world!&apos;)</div><div class="line"></div><div class="line">print &quot;m.string:&quot;, m.string</div><div class="line">print &quot;m.re:&quot;, m.re</div><div class="line">print &quot;m.pos:&quot;, m.pos</div><div class="line">print &quot;m.endpos:&quot;, m.endpos</div><div class="line">print &quot;m.lastindex:&quot;, m.lastindex</div><div class="line">print &quot;m.lastgroup:&quot;, m.lastgroup</div><div class="line"></div><div class="line">print &quot;m.group(1,2):&quot;, m.group(1, 2)</div><div class="line">print &quot;m.groups():&quot;, m.groups()</div><div class="line">print &quot;m.groupdict():&quot;, m.groupdict()</div><div class="line">print &quot;m.start(2):&quot;, m.start(2)</div><div class="line">print &quot;m.end(2):&quot;, m.end(2)</div><div class="line">print &quot;m.span(2):&quot;, m.span(2)</div><div class="line">print r&quot;m.expand(r&apos;2 13&apos;):&quot;, m.expand(r&apos;2 13&apos;)</div><div class="line"></div><div class="line">### output ###</div><div class="line"># m.string: hello world!</div><div class="line"># m.re: &lt;_sre.SRE_Pattern object at 0x016E1A38&gt;</div><div class="line"># m.pos: 0</div><div class="line"># m.endpos: 12</div><div class="line"># m.lastindex: 3</div><div class="line"># m.lastgroup: sign</div><div class="line"># m.group(1,2): (&apos;hello&apos;, &apos;world&apos;)</div><div class="line"># m.groups(): (&apos;hello&apos;, &apos;world&apos;, &apos;!&apos;)</div><div class="line"># m.groupdict(): &#123;&apos;sign&apos;: &apos;!&apos;&#125;</div><div class="line"># m.start(2): 6</div><div class="line"># m.end(2): 11</div><div class="line"># m.span(2): (6, 11)</div><div class="line"># m.expand(r&apos;2 13&apos;): world hello!</div></pre></td></tr></table></figure></1></p>
<p>2.3. Pattern<br>Pattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。<br>Pattern不能直接实例化，必须使用re.compile()进行构造。<br>Pattern提供了几个可读属性用于获取表达式的相关信息：<br>pattern: 编译时用的表达式字符串。<br>flags: 编译时用的匹配模式。数字形式。<br>groups: 表达式中分组的数量。<br>groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">p = re.compile(r&apos;(w+) (w+)(?P.*)&apos;, re.DOTALL)</div><div class="line"></div><div class="line">print &quot;p.pattern:&quot;, p.pattern</div><div class="line">print &quot;p.flags:&quot;, p.flags</div><div class="line">print &quot;p.groups:&quot;, p.groups</div><div class="line">print &quot;p.groupindex:&quot;, p.groupindex</div><div class="line"></div><div class="line">### output ###</div><div class="line"># p.pattern: (w+) (w+)(?P.*)</div><div class="line"># p.flags: 16</div><div class="line"># p.groups: 3</div><div class="line"># p.groupindex: &#123;&apos;sign&apos;: 3&#125;</div></pre></td></tr></table></figure></p>
<p>实例方法[ | re模块方法]：<br>match(string[, pos[, endpos]]) | re.match(pattern, string[, flags]):<br>这个方法将从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。<br>pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。<br>注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’。<br>示例参见2.1小节。<br>search(string[, pos[, endpos]]) | re.search(pattern, string[, flags]):<br>这个方法用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。<br>pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># encoding: UTF-8</div><div class="line">import re</div><div class="line"></div><div class="line"># 将正则表达式编译成Pattern对象</div><div class="line">pattern = re.compile(r&apos;world&apos;)</div><div class="line"></div><div class="line"># 使用search()查找匹配的子串，不存在能匹配的子串时将返回None</div><div class="line"># 这个例子中使用match()无法成功匹配</div><div class="line">match = pattern.search(&apos;hello world!&apos;)</div><div class="line"></div><div class="line">if match:</div><div class="line">    # 使用Match获得分组信息</div><div class="line">    print match.group()</div><div class="line"></div><div class="line">### 输出 ###</div><div class="line"># world</div></pre></td></tr></table></figure></p>
<p>split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]):<br>按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">p = re.compile(r&apos;d+&apos;)</div><div class="line">print p.split(&apos;one1two2three3four4&apos;)</div><div class="line"></div><div class="line">### output ###</div><div class="line"># [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;, &apos;&apos;]</div></pre></td></tr></table></figure></p>
<p>findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags]):<br>搜索string，以列表形式返回全部能匹配的子串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">p = re.compile(r&apos;d+&apos;)</div><div class="line">print p.findall(&apos;one1two2three3four4&apos;)</div><div class="line"></div><div class="line">### output ###</div><div class="line"># [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]</div></pre></td></tr></table></figure></p>
<p>finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags]):<br>搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">p = re.compile(r&apos;d+&apos;)</div><div class="line">for m in p.finditer(&apos;one1two2three3four4&apos;):</div><div class="line">    print m.group(),</div><div class="line"></div><div class="line">### output ###</div><div class="line"># 1 2 3 4</div></pre></td></tr></table></figure></p>
<p>sub(repl, string[, count]) | re.sub(pattern, repl, string[, count]):<br>使用repl替换string中每一个匹配的子串后返回替换后的字符串。<br>当repl是一个字符串时，可以使用id或g、g引用分组，但不能使用编号0。<br>当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。<br>count用于指定最多替换次数，不指定时全部替换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">p = re.compile(r&apos;(w+) (w+)&apos;)</div><div class="line">s = &apos;i say, hello world!&apos;</div><div class="line"></div><div class="line">print p.sub(r&apos;2 1&apos;, s)</div><div class="line"></div><div class="line">def func(m):</div><div class="line">    return m.group(1).title() + &apos; &apos; + m.group(2).title()</div><div class="line"></div><div class="line">print p.sub(func, s)</div><div class="line"></div><div class="line">### output ###</div><div class="line"># say i, world hello!</div><div class="line"># I Say, Hello World!</div></pre></td></tr></table></figure></p>
<p>subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]):<br>返回 (sub(repl, string[, count]), 替换次数)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line"></div><div class="line">p = re.compile(r&apos;(w+) (w+)&apos;)</div><div class="line">s = &apos;i say, hello world!&apos;</div><div class="line"></div><div class="line">print p.subn(r&apos;2 1&apos;, s)</div><div class="line"></div><div class="line">def func(m):</div><div class="line">    return m.group(1).title() + &apos; &apos; + m.group(2).title()</div><div class="line"></div><div class="line">print p.subn(func, s)</div><div class="line"></div><div class="line">### output ###</div><div class="line"># (&apos;say i, world hello!&apos;, 2)</div><div class="line"># (&apos;I Say, Hello World!&apos;, 2)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 后端语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS限制textarea输入框输入字数]]></title>
      <url>/2017/07/07/JS%E9%99%90%E5%88%B6textarea%E8%BE%93%E5%85%A5%E6%A1%86%E8%BE%93%E5%85%A5%E5%AD%97%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>最近工作遇到限制textarea输入框输入字数，自己在网上搜了搜，找到一些，特此分享一下！<br>第一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;textarea onpropertychange=&quot;if(value.length&gt;100) value=value.substr(0,100)&quot; class=&quot;smallArea&quot; cols=&quot;60&quot; name=&quot;txta&quot; rows=&quot;8&quot;&gt;&lt;/textarea&gt;</div></pre></td></tr></table></figure></p>
<p>第二种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;textarea onkeyup=&quot;checkLen(this)&quot;&gt;&lt;/textarea&gt; </div><div class="line">&lt;div&gt;您还可以输入 &lt;span id=&quot;count&quot;&gt;200&lt;/span&gt; 个文字&lt;/div&gt; </div><div class="line"> </div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt; </div><div class="line">function checkLen(obj) </div><div class="line">&#123; </div><div class="line">    var maxChars = 200;//最多字符数 </div><div class="line">    if (obj.value.length &gt; maxChars) </div><div class="line">    obj.value = obj.value.substring(0,maxChars); </div><div class="line">    var curr = maxChars - obj.value.length; </div><div class="line">    document.getElementById_x(&quot;count&quot;).innerHTML = curr.toString(); </div><div class="line">&#125; </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>第三种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</div><div class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;</div><div class="line">&lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;</div><div class="line">&lt;meta name=&quot;author&quot; content=&quot;,混蛋鱼&quot; /&gt;</div><div class="line">&lt;meta name=&quot;Copyright&quot; content=&quot;混蛋鱼VS男人猫 CopyRight 2007&quot; /&gt;</div><div class="line">&lt;meta name=&quot;keywords&quot; content=&quot;JS,Blog,ASP,designing,with,web,standards,xhtml,css,graphic,design,layout,usability,accessibility,w3c,w3,w3cn&quot; /&gt;</div><div class="line">&lt;meta name=&quot;description&quot; content=&quot;JS限制textarea输入框输入字数&quot; /&gt;</div><div class="line">&lt;title&gt;JS限制textarea输入框输入字数&lt;/title&gt;</div><div class="line">&lt;SCRIPT language=&quot;javascript&quot;&gt;</div><div class="line">&lt;!--</div><div class="line">function checktext(text)</div><div class="line">&#123;</div><div class="line">   allValid = true;</div><div class="line">   for (i = 0; i &lt; text.length; i++)</div><div class="line">   &#123;</div><div class="line">    if (text.charAt(i) != &quot; &quot;)</div><div class="line">    &#123;</div><div class="line">     allValid = false;</div><div class="line">     break;</div><div class="line">    &#125;</div><div class="line">   &#125;</div><div class="line">return allValid;</div><div class="line">&#125;</div><div class="line">function gbcount(message,total,used,remain)</div><div class="line">&#123;</div><div class="line">var max;</div><div class="line">max = total.value;</div><div class="line">if (message.value.length &gt; max) &#123;</div><div class="line">message.value = message.value.substring(0,max);</div><div class="line">used.value = max;</div><div class="line">remain.value = 0;</div><div class="line">alert(&quot;留言不能超过 200 个字!&quot;);</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">used.value = message.value.length;</div><div class="line">remain.value = max - used.value;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">--&gt;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">&lt;!--</div><div class="line">* &#123;padding:0; margin:0;&#125;</div><div class="line">body, html &#123;text-align:left; font-size:12px; line-height:150%; margin:0 auto; background:#fff; padding-top:20px;&#125;</div><div class="line">fieldset &#123;padding:10px; width:550px; margin:0 auto;&#125;</div><div class="line">legend &#123;font-size:14px; font-weight:bold;&#125;</div><div class="line">.inputtext &#123;border:none; background:#fff;&#125;</div><div class="line">--&gt;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;form action=&quot;SaveData.asp&quot; method=&quot;post&quot; onSubmit=&quot;return datacheck();&quot;&gt;</div><div class="line">&lt;fieldset&gt;&lt;legend&gt;请输入内容&lt;/legend&gt;</div><div class="line">&lt;textarea name=&quot;Memo&quot; rows=&quot;10&quot; wrap=PHYSICAL cols=&quot;75&quot; onKeyDown=&quot;gbcount(this.form.Memo,this.form.total,this.form.used,this.form.remain);&quot; onKeyUp=&quot;gbcount(this.form.Memo,this.form.total,this.form.used,this.form.remain);&quot;&gt;&lt;/textarea&gt;</div><div class="line">&lt;p&gt;最多字数：</div><div class="line">&lt;input disabled maxLength=&quot;4&quot; name=&quot;total&quot; size=&quot;3&quot; value=&quot;200&quot; class=&quot;inputtext&quot;&gt;</div><div class="line">已用字数：</div><div class="line">&lt;input disabled maxLength=&quot;4&quot; name=&quot;used&quot; size=&quot;3&quot; value=&quot;0&quot; class=&quot;inputtext&quot;&gt;</div><div class="line">剩余字数：</div><div class="line">&lt;input disabled maxLength=&quot;4&quot; name=&quot;remain&quot; size=&quot;3&quot; value=&quot;200&quot; class=&quot;inputtext&quot;&gt;&lt;/td&gt;</div><div class="line">&lt;/p&gt;</div><div class="line">&lt;/fieldset&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
            <tag> js </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[屏蔽双击选中文字的解决办法，兼容ie，google，firefox]]></title>
      <url>/2017/07/07/%E5%B1%8F%E8%94%BD%E5%8F%8C%E5%87%BB%E9%80%89%E4%B8%AD%E6%96%87%E5%AD%97%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%8C%E5%85%BC%E5%AE%B9ie%EF%BC%8Cgoogle%EF%BC%8Cfirefox/</url>
      <content type="html"><![CDATA[<p>IE及Chrome下的方法一样，对相应的元素添加onselectstart=”return false;”但是，这个在火狐下不起作用，但是火狐下可以用css样式来达到这个效果，即添加-moz-user-select:none;就可以兼容ie，google，firefox了，即代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;picBox&quot; onselectstart=&quot;return false;&quot; style=&quot;-moz-user-select:none;&quot;&gt;屏蔽双击选中文字的区域&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>这样这个区域的文字都不能选中了，就也不会出现在双击左右箭头快速切换图片滚动时会选择附近区域文字的情况了<br>如果把<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;body onselectstart=&quot;return false&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">body&#123;-moz-user-select:   none;&#125;</div></pre></td></tr></table></figure></p>
<p>添加到body中，就实现了禁止用户选中页面上内容的效果</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SlipJs快速使用教程]]></title>
      <url>/2017/07/06/SlipJs%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>之前有一个拖动排序的jq插件，但是有弊端不能在移动端生效，今天找到一个slipjs，在移动端可以执行。<br>进入正题  如何使用SlipJs，很简单只要两步：<br>提示：具体如何使用SlipJs实现演示例子slipjs.com/demo中的效果，请下载并参考演示例子的源码，下载地址：www.slipjs.com<br>第一步： 载入slip.js，你只需下载并在你的页面中载入slip.js；<br>第二步： 使用函数slip(mode, core, para)；<br>该函数有三个参数:　　<br>第一个参数：mode ，可以为”px”或者”page”。<br>为”px”     时将实现惯性滚动的效果（类似slipjs.com/dome中的第一个例子），<br>为”page” 时将实现类似图片轮换的换屏效果（类似slipjs.com/dome中的第一个例子）。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">slip(&quot;px&quot;,  core,  para); </div><div class="line">// 或者</div><div class="line">slip(&quot;page&quot;,  core,  para);</div></pre></td></tr></table></figure></p>
<p>第二个参数：core ，这个参数传递的是运动的对象，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var core = document.getElementById(&quot;core&quot;);</div><div class="line">slip(&apos;px&apos;, core, para);</div></pre></td></tr></table></figure></p>
<p>第三个参数：para ，这个参数是一个对象子面量，该参数在px惯性滚动状态下和在page换屏状态下可传递的内容存在差别。<br>首先是这两种状态下均可传递的参数有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">slip(&apos;px&apos;, core, &#123;</div><div class="line">        startFun: function,   // 触摸开始时执行的函数</div><div class="line">         moveFun: function,   // 触摸过程中执行的函数</div><div class="line">     touchEndFun: function,   // 触摸结束时执行的函数</div><div class="line">          endFun: function    // 滑动结束时执行的函数</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>page换屏状态下独有的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">slip(&apos;page&apos;, core, &#123;</div><div class="line">              num: 3,        // 屏数，例如轮换图片是图片的张数（必需）</div><div class="line">      change_time: 3000,     // 图片自动轮换的时间</div><div class="line">      lastPageFun: function, // 用户在滑动到最后一屏后仍然滑动下一屏时执行的函数（可用于图片浏览时使用）,更详细请看下文</div><div class="line">     firstPageFun: function, // 用户在滑动到第一屏后仍然滑动上一屏时执行的函数（可用于图片浏览时使用），更详细请看下文</div><div class="line">        no_follow: true      // 是否跟随手指移动来完成换屏，ture为不跟随，默认跟随，更详细请看下文</div><div class="line">             loop: true      // slipjs3.5.0开始支持，可以实现无限滑动下一张（最后一张时继续滑可以回到第一张）</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>px惯性滚动状态下独有的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">slip(&apos;px&apos;, core, &#123;</div><div class="line">       direction: &apos;x&apos;,   // 设置滑动方向,&quot;x&quot;为横向滑动，默认为纵向滑动。</div><div class="line">         perfect: true,  // 是否启用完美模式，true为启用，何为完美模式，更详细请看下文</div><div class="line">          no_bar: true,  // 是否启用模仿滚动条，true为不启用，默认启用</div><div class="line">     bar_no_hide: true,  // 是否在滚动停止时隐藏滚动条，true为不隐藏，默认隐藏</div><div class="line">      core_width: 1000,  // 滑动元素的宽度或者高度，单位为px（横向滑动时传递宽度，纵向滑动时传递高度），更详细请看下文</div><div class="line">           width: 400,   // 滑动元素的父级元素的宽度或者高度，单位为px（横向滑动时传递宽度，纵向滑动时传递高度），更详细请看下文</div><div class="line">         bar_css: &quot;background-color: rgba(8, 97, 149, 0.5);&quot;  // 自定义滚动条的样式</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>现在你就可以预览效果了。<br>更详细的参数说明<br>看到这里如果你存在疑问那我猜可能会集中在几个参数的用法上，这些参数包括<br>page换屏状态下的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lastPageFun: function, // 用户在滑动到最后一屏后仍然滑动下一屏时执行的函数（可用于图片浏览时使用）,更详细请看下文</div><div class="line">firstPageFun: function, // 用户在滑动到第一屏后仍然滑动上一屏时执行的函数（可用于图片浏览时使用），更详细请看下文</div><div class="line">   no_follow: true      // 是否跟随手指移动来完成换屏，ture为不跟随，默认跟随，更详细请看下文</div></pre></td></tr></table></figure></p>
<p>px惯性滚动状态下的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perfect: true,  // 是否启用完美模式，true为启用，何为完美模式，更详细请看下文</div></pre></td></tr></table></figure></p>
<p>接下来我将一个个详细讲解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lastPageFun: function // 用户在滑动到最后一屏后仍然滑动下一屏时执行的函数。</div><div class="line">//你想象一下：你现在是用px换屏模式来做一个图片放大并可滑动查看下一张的功能，这时你的用户滑动到了</div><div class="line">最后一张还想继续查看下一张，你想提醒用户已经到最后一张了，那么这些提示的代码就可以放在这个函数中。</div><div class="line">no_follow: true      // 是否跟随手指移动来完成换屏，ture为不跟随，默认跟随。以图片轮换为例，</div><div class="line">你可能发现现在互联网上的手机网站图片轮换功能基本可以分为两类，一类是你手指在上面滑动的时候图片会跟随你手指移动，</div><div class="line">另一类是你手指在上面滑动时没有反应，只有你手指离开的时候吹滑动到下一张。通过这个参数你可以任选一种适合你的方式。</div><div class="line">perfect: true  // 是否启用完美模式，true为启用，何为完美模式。所谓完美模式是对应流畅模式而言的，</div><div class="line">完美模式和流畅模式的区别表现在于滚动条的变化，完美模式下滚动条在滚动到底部或者顶部的时候大小会变化，</div><div class="line">而流畅模式则没这个视觉效果。理论上流畅模式要比完美模式反应效率等各方面更快，其中的区别在表现上是滚</div><div class="line">动条的区别，其实是实现形式的不同使得流畅模式的无法实现这一视觉效果。</div></pre></td></tr></table></figure></p>
<p>也是刚刚找到还不是很了解 ，不知道能否变换位置之后如何存储！有了解的可以回复补充，谢谢！<br>多多支持！！！！</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ SlipJs API详细]]></title>
      <url>/2017/07/06/SlipJs-API%E8%AF%A6%E7%BB%86/</url>
      <content type="html"><![CDATA[<p>refresh(core_width, width)：<br>当在滚动对象的大小发生改变时（如：当用户滚动到底部时你通过ajax加载新内容，这时元素的尺寸会改变）必须调用refresh方法。主要用处是让SlipJs及时感知尺寸的变化以便正常工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 参数说明:这两个参数都是可选的。</div><div class="line">// core_width: 滑动元素的宽度或者高度，单位为px（横向滑动时传递宽度，纵向滑动时传递高度）</div><div class="line">// width:      滑动元素的父级元素的宽度或者高度，单位为px（横向滑动时传递宽度，纵向滑动时传递高度）</div><div class="line">// 例如：</div><div class="line">var slipjs = slipjs(&apos;px&apos;,core);</div><div class="line"> </div><div class="line">// 当元素的尺寸改变时，我们需要将新的尺寸给refresh:</div><div class="line">slipjs.refresh(1000,400);</div><div class="line">// 也可以不传递参数，这时SlipJs将自己通过获取元素的实际尺寸。</div></pre></td></tr></table></figure></p>
<p>toPage(num, time)：<br>page换屏状态下是用toPage可以滑动到指定屏数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 参数说明：</div><div class="line">// num  : 要到达的屏数</div><div class="line">// time : 设定过程花费的时间,单位ms</div><div class="line">// 例如 :</div><div class="line">var slipjs = slip(&apos;page&apos;, core, &#123;</div><div class="line">    num: 3</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 这时我们想要用3秒的时间缓慢地轮换到第3屏就可以这样：</div><div class="line">slipjs.toPage(3, 3000);</div></pre></td></tr></table></figure></p>
<p>that.page<br>可在page换屏状态的startFun  moveFun  touchEndFun  endFun 这4个函数中获取当前所在的页（屏）数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function end() &#123;</div><div class="line">    alert(this.page);// 在滑动结束后输出当前的页(屏)数</div><div class="line">&#125;</div><div class="line">slip(&apos;page&apos;, bar_list_div, &#123;</div><div class="line">    num: 3,</div><div class="line">    endFun: end</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>提示：该api在图片轮换中导航小点的变化需要用到该api。<br>注释：关于startFun  moveFun  touchEndFun  endFun 这4个函数的用法详见：<a href="/2017/07/06/SlipJs快速使用教程/" title="SlipJs快速使用教程">SlipJs快速使用教程</a><br>this.xy<br>当你想在 startFun  moveFun  touchEndFun  endFun 这4个函数中获取滑动元素的坐标时可直接使用 this.xy 来获取，当状态为横向滑动时该值是滑动元素的x坐标，当状态为纵向滑动时该值是滑动元素的y坐标。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function move() &#123;</div><div class="line">    console.log(this.xy);// 在滑动过程中输出滑动元素当前的y坐标</div><div class="line">&#125;</div><div class="line">slip(&apos;px&apos;, bar_list_div, &#123;</div><div class="line">    moveFun: move</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>提示：该api在“下拉刷新”的例子中使用到，在加载数据时非常有用。<br>this.wide_high（3.0.1开始支持）<br>当你想在 startFun  moveFun  touchEndFun  endFun 这4个函数中获取滑动元素的宽或者高（横向滑动的时候是宽，上下滑动时是高）可直接使用 this.wide_high来获取，当状态为横向滑动时该值是滑动元素的width，当状态为纵向滑动时该值是滑动元素的height。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function move() &#123;</div><div class="line">    console.log(this.wide_high);// 在滑动过程中输出滑动元素当前的y坐标</div><div class="line">&#125;</div><div class="line">slip(&apos;px&apos;, bar_list_div, &#123;</div><div class="line">    moveFun: move</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>this.parent_wide_high（3.0.1开始支持）<br>当你想在 startFun  moveFun  touchEndFun  endFun 这4个函数中获取滑动元素父级元素的宽或者高（横向滑动的时候是宽，上下滑动时是高）可直接使用 this.parent_wide_high来获取，当状态为横向滑动时该值是父级元素的width，当状态为纵向滑动时该值是父级元素的height。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function move() &#123;</div><div class="line">    console.log(this.parent_wide_high);// 在滑动过程中输出滑动元素当前的y坐标</div><div class="line">&#125;</div><div class="line">slip(&apos;px&apos;, bar_list_div, &#123;</div><div class="line">    moveFun: move</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>backward和forward（3.5.0开始支持）<br>以图片轮换为例，现在你想要添加两个按钮，一个按钮为“上一张”，另一个为“下一张”，那么这是你就可以是使用backward和forward了，具体使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var slip_img = slip(&apos;page&apos;,change_screen_ul,&#123;</div><div class="line">        change_time: 5000,</div><div class="line">                      num: 3</div><div class="line">&#125;);</div><div class="line">document.getElementById(&quot;backward&quot;).onclick = function()&#123;</div><div class="line">    slip_img.backward(); // 上一张</div><div class="line">&#125;</div><div class="line">document.getElementById(&quot;forward&quot;).onclick = function()&#123;</div><div class="line">    slip_img.forward(); // 下一张</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>等待大神的到来！！！</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ javascript(window.onresize)事件获取窗口大小]]></title>
      <url>/2017/07/06/javascript-window-onresize-%E4%BA%8B%E4%BB%B6%E8%8E%B7%E5%8F%96%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</div><div class="line">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</div><div class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;请调整浏览器窗口&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;h2 align=&quot;center&quot;&gt;请调整浏览器窗口大小&lt;/h2&gt;&lt;hr&gt;</div><div class="line">    &lt;form action=&quot;#&quot; method=&quot;get&quot; name=&quot;form1&quot; id=&quot;form1&quot;&gt;</div><div class="line">        &lt;!--显示浏览器窗口的实际尺寸--&gt;</div><div class="line">        浏览器窗口 的实际高度: &lt;input type=&quot;text&quot; name=&quot;availHeight&quot; size=&quot;4&quot;&gt;&lt;br&gt;</div><div class="line">        浏览器窗口 的实际宽度: &lt;input type=&quot;text&quot; name=&quot;availWidth&quot; size=&quot;4&quot;&gt;&lt;br&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    &lt;!--</div><div class="line">        var winWidth = 0;</div><div class="line">        var winHeight = 0;</div><div class="line">        function findDimensions() //函数：获取尺寸</div><div class="line">        &#123;</div><div class="line">             //获取窗口宽度</div><div class="line">             if (window.innerWidth)</div><div class="line">                   winWidth = window.innerWidth;</div><div class="line">             else if ((document.body) &amp;&amp; (document.body.clientWidth))</div><div class="line">                   winWidth = document.body.clientWidth;</div><div class="line">             //获取窗口高度</div><div class="line">             if (window.innerHeight)</div><div class="line">                   winHeight = window.innerHeight;</div><div class="line">             else if ((document.body) &amp;&amp; (document.body.clientHeight))</div><div class="line">                   winHeight = document.body.clientHeight;</div><div class="line">            </div><div class="line">             //通过深入Document内部对body进行检测，获取窗口大小</div><div class="line">             if (document.documentElement &amp;&amp; document.documentElement.clientHeight &amp;&amp; document.documentElement.clientWidth)</div><div class="line">             &#123;</div><div class="line">                 winHeight = document.documentElement.clientHeight;</div><div class="line">                 winWidth = document.documentElement.clientWidth;</div><div class="line">             &#125;</div><div class="line">              </div><div class="line">             //结果输出至两个文本框</div><div class="line">             document.form1.availHeight.value= winHeight;</div><div class="line">             document.form1.availWidth.value= winWidth;</div><div class="line">        &#125;</div><div class="line">        findDimensions();                  //调用函数，获取数值</div><div class="line">        window.onresize=findDimensions;</div><div class="line">    //--&gt;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jq 日期插件]]></title>
      <url>/2017/07/06/jq-%E6%97%A5%E6%9C%9F%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>在工作中遇到的，需要做一个日期插件，所以整合了一下，分享一下，供大家使用。 效果如下： 做的并不完善，希望大神们可以帮着完善并分享至本模块。一起进步。<br>如果有啥意见建议可以留言！<br>代码地址如下:<br><a href="https://github.com/twang211/webdemo/tree/master/date-new" target="_blank" rel="external">https://github.com/twang211/webdemo/tree/master/date-new</a></p>
]]></content>
      
        <categories>
            
            <category> 插件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
            <tag> jQuery </tag>
            
            <tag> 插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[web app iphone4 iphone5 iphone6 响应式布局 适配代码]]></title>
      <url>/2017/07/06/web-app-iphone4-iphone5-iphone6-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80-%E9%80%82%E9%85%8D%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>现在满大街的APP，除了游戏，软件图形类的需要用原生开发好点。现在大多还是基于WEBAPP或者混合的hybrid app，大家都知道资讯类的小应用其实网页就可以胜任，当然如果你要调用一些应设备，原生的APP外hybrid app也是一个不错的选择。不过我们今天的主角是WEB APP,WEB APP好处就是，随时随地有网就能看，简单实用。对于开发来说，更是高效率低成本，当然对于追求细致的来说。。。就有点。。。。。好了，下面我们来看看WEB APP怎么区分iphone 4 5 6吧<br>那么-webkit-min-device-pixel-ratio:2可以用来区分iphone(4/4s/5)和其它的手机<br>iPhone4/4s的分辨率为640<em>960 pixels，DPI为是320</em>480，设备高度为480px<br>iPhone5的分辨率为640<em>1136 pixels，DPI依然是320</em>568，设备高度为568px<br>iPhone6的分辨率为750<em>1334 pixels，DPI依然是375</em>667，设备高度为667px<br>iPhone6 Plus的分辨率为1242x2208 pixels，DPI依然是414*736，设备高度为736px<br>那么我们只需要判断iphone手机的device-height(设备高)值即可区别iPhone4和iPhone5、iPhone6、iPhone6 Plus使用css<br>通过 CSS3 的 Media Queries 特性，可以写出兼容iPhone4和iPhone5、iPhone6、iPhone6 Plus的代码~~<br>方式一，直接写到样式里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;font face=&quot;宋体&quot;&gt;&lt;font style=&quot;font-size:12px&quot;&gt;&lt;font color=&quot;Black&quot;&gt;&lt;strong&gt;&lt;font face=&quot;宋体&quot;&gt;&lt;font style=&quot;font-size:12px&quot;&gt;&lt;font color=&quot;Black&quot;&gt;&lt;strong&gt;@media (device-height:480px) and (-webkit-min-device-pixel-ratio:2)&#123;/* 兼容iphone4/4s */</div><div class="line">  </div><div class="line">    .class&#123;&#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">  </div><div class="line">@media (device-height:568px) and (-webkit-min-device-pixel-ratio:2)&#123;/* 兼容iphone5 */</div><div class="line">  </div><div class="line">    .class&#123;&#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">  </div><div class="line">  </div><div class="line">@media (device-height:667px) and (-webkit-min-device-pixel-ratio:2)&#123;/* 兼容iphone6 */</div><div class="line">  </div><div class="line">    .class&#123;&#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line">  </div><div class="line">@media (device-height:736px) and (-webkit-min-device-pixel-ratio:2)&#123;/* 兼容iphone6 Plus */</div><div class="line">  </div><div class="line">    .class&#123;&#125;</div><div class="line">  </div><div class="line">&#125;&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;</div></pre></td></tr></table></figure></p>
<p>方式二，链接到一个单独的样式表，把下面的代码放在标签里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;font face=&quot;宋体&quot;&gt;&lt;font style=&quot;font-size:12px&quot;&gt;&lt;font color=&quot;Black&quot;&gt;&lt;strong&gt;&lt;font face=&quot;宋体&quot;&gt;&lt;font style=&quot;font-size:12px&quot;&gt;&lt;font color=&quot;Black&quot;&gt;&lt;strong&gt;&lt;link rel=&quot;stylesheet&quot; media=&quot;(device-height: 480px) and (-webkit-min-device-pixel-ratio:2)&quot; href=&quot;iphone4.css&quot;&gt;</div><div class="line">  </div><div class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;(device-height: 568px)and (-webkit-min-device-pixel-ratio:2)&quot; href=&quot;iphone5.css&quot;&gt;</div><div class="line">  </div><div class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;(device-height: 667px)and (-webkit-min-device-pixel-ratio:2)&quot; href=&quot;iphone6.css&quot;&gt;</div><div class="line">  </div><div class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;(device-height: 736px)and (-webkit-min-device-pixel-ratio:2)&quot; href=&quot;iphone6p.css&quot;&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;</div></pre></td></tr></table></figure>
<p>使用Js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;font face=&quot;宋体&quot;&gt;&lt;font style=&quot;font-size:12px&quot;&gt;&lt;font color=&quot;Black&quot;&gt;&lt;strong&gt;&lt;font face=&quot;宋体&quot;&gt;&lt;font style=&quot;font-size:12px&quot;&gt;&lt;font color=&quot;Black&quot;&gt;&lt;strong&gt;//通过高度来判断是否是iPhone 4还是iPhone 5或iPhone 6、iPhone6 Plus</div><div class="line">  </div><div class="line">isPhone4inches = (window.screen.height==480);</div><div class="line">  </div><div class="line">isPhone5inches = (window.screen.height==568);</div><div class="line">  </div><div class="line">isPhone6inches = (window.screen.height==667);</div><div class="line">  </div><div class="line">isPhone6pinches = (window.screen.height==736);&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/font&gt;&lt;/font&gt;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
            <tag> Js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用javascript对url编码和使用python进行解码]]></title>
      <url>/2017/07/06/%E4%BD%BF%E7%94%A8javascript%E5%AF%B9url%E7%BC%96%E7%A0%81%E5%92%8C%E4%BD%BF%E7%94%A8python%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>本文讨论javascript和python的 url编码解码函数<br>如果一个url带有动态参数，那么这个url就很难被当做其他url的参数进行传递了，因为浏览器无法正确识别，这个时候就需要对url进行编码，把不是字母数字的字符转换成%的形式<br>javascript对url进行编码的函数有3个，escape，encodeURI，encodeURIComponent 推荐使用最后一个，因为encodeURIComponent()不编码的字符最少，只有5个<br>~!*()’<br>encodeURIComponent和decodeURIComponent 可以成对使用<br>对应python的函数是urllib.quote 和 urllib.unquote，也可以成对使用<br>在client端用encodeURIComponent编码，在服务器端可以用urllib.unquote解码</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> WEB </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[30行js让你的rem弹性布局适配所有分辨率(含竖屏适配)]]></title>
      <url>/2017/07/06/30%E8%A1%8Cjs%E8%AE%A9%E4%BD%A0%E7%9A%84rem%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E9%80%82%E9%85%8D%E6%89%80%E6%9C%89%E5%88%86%E8%BE%A8%E7%8E%87-%E5%90%AB%E7%AB%96%E5%B1%8F%E9%80%82%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>用rem来实现移动端的弹性布局是个好主意！用法如下：<br>CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@media only screen and (max-width: 320px), only screen and (max-device-width:320px) &#123;    html &#123;      font-size:10px;</div><div class="line">    &#125;&#125;@media only screen and (max-width: 640px), only screen and (max-device-width:640px) &#123;    html &#123;      font-size:20px;</div><div class="line">    &#125;&#125;.test-div&#123;width: 10rem;&#125;</div></pre></td></tr></table></figure></p>
<p>那么这个.test-div的宽度在320px的分辨率下会是10 <em> 10 = 100px, 在640下是10 </em> 20 = 200px，从而达到了弹性缩放的目的。<br>但是这样做还是有2个问题：</p>
<ol>
<li>随着各种新手机的发布，分辨率也碎片化了，我们无法预知将来会出现的分辨率宽度，我们不可能把所有要兼容的分辨率写到css里。</li>
<li>这样写只能做到页面适配不同的宽度，对于那种在各种屏幕上都要在一屏幕内显示的页面，就没有办法适配了。<br>比如这种非常流行的整屏滑动页面，当屏幕宽高比小于设计稿的比例时会缩放：</li>
</ol>
<p>所以完美解决适配的问题就得靠js了，思路非常简单，判断一下当前终端的宽度（这里在安卓上有个坑，后面会说）和设计稿宽度的比例，计算出需要缩放的倍数，然后根据这个倍数值改变html的字体大小即可。<br>如果需要横竖屏都适配，那么根据终端宽高比例较小的那一个来计算。用通俗的语言来说，如果终端屏幕比设计稿更加宽矮一些，那么久根据它和设计稿的高度比例来计算字体。<br>思路永远是简单，实现永远是有问题需要解决的，先上代码：<br><a href="https://github.com/twang211/webdemo/tree/master/setHtmlRem" target="_blank" rel="external">https://github.com/twang211/webdemo/tree/master/setHtmlRem</a><br>JAVASCRIPT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">&lt;font style=&quot;color:rgb(51, 51, 51)&quot;&gt;console.time(&quot;test&quot;);/*</div><div class="line">    # 按照宽高比例设定html字体, width=device-width initial-scale=1版</div><div class="line">    # @pargam win 窗口window对象</div><div class="line">    # @pargam option&#123;</div><div class="line">      designWidth: 设计稿宽度，必须</div><div class="line">      designHeight: 设计稿高度，不传的话则比例按照宽度来计算，可选</div><div class="line">      designFontSize: 设计稿宽高下用于计算的字体大小，默认20，可选</div><div class="line">      callback: 字体计算之后的回调函数，可选</div><div class="line">    &#125;</div><div class="line">    # return Boolean;</div><div class="line">    # &lt;a href=&quot;mailto:twang211@gmail.com&quot;&gt;twang211@gmail.com&lt;/a&gt;</div><div class="line">    # ps:请尽量第一时间运行此js计算字体</div><div class="line">*/!function(win, option) &#123;  var count = 0, </div><div class="line">      designWidth = option.designWidth, </div><div class="line">      designHeight = option.designHeight || 0, </div><div class="line">      designFontSize = option.designFontSize || 20, </div><div class="line">      callback = option.callback || null,</div><div class="line">      root = document.documentElement,</div><div class="line">      body = document.body,</div><div class="line">      rootWidth, newSize, t, self;</div><div class="line">      root.style.width = 100%;  //返回root元素字体计算结果</div><div class="line">  function _getNewFontSize() &#123;</div><div class="line">    var scale = designHeight !== 0 ? Math.min(win.innerWidth / designWidth, win.innerHeight / designHeight) : win.innerWidth / designWidth;    return parseInt( scale * 10000 * designFontSize ) / 10000;</div><div class="line">  &#125;</div><div class="line">  !function () &#123;</div><div class="line">    rootWidth = root.getBoundingClientRect().width;    self = self ? self : arguments.callee;    //如果此时屏幕宽度不准确，就尝试再次获取分辨率，只尝试20次，否则使用win.innerWidth计算</div><div class="line">    if( rootWidth !== win.innerWidth &amp;&amp;  count &lt; 20 ) &#123;</div><div class="line">      win.setTimeout(function () &#123;</div><div class="line">        count++;        self();</div><div class="line">      &#125;, 0);</div><div class="line">    &#125; else &#123;</div><div class="line">      newSize = _getNewFontSize();      //如果css已经兼容当前分辨率就不管了</div><div class="line">      if( newSize + &apos;px&apos; !== getComputedStyle(root)[&apos;font-size&apos;] ) &#123;</div><div class="line">        root.style.fontSize = newSize + &quot;px&quot;;        return callback &amp;&amp; callback(newSize);</div><div class="line">      &#125;;</div><div class="line">    &#125;;</div><div class="line">  &#125;();  //横竖屏切换的时候改变fontSize，根据需要选择使用</div><div class="line">  win.addEventListener(&quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;, function() &#123;</div><div class="line">    clearTimeout(t);</div><div class="line">    t = setTimeout(function () &#123;</div><div class="line">      self();</div><div class="line">    &#125;, 300);</div><div class="line">  &#125;, false);</div><div class="line">&#125;(window, &#123;</div><div class="line">  designWidth: 640, </div><div class="line">  designHeight: 1136,</div><div class="line">  designFontSize: 20,</div><div class="line">  callback: function (argument) &#123;</div><div class="line">    console.timeEnd(&quot;test&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;);&lt;/font&gt;</div></pre></td></tr></table></figure>
<p>然后再说几个点和问题：1. 这段代码对viewport有要求，必须是width=device-width initial-scale=1，即窗口的大小是设备物理宽度(分辨率 / devicePixelRatio)，并且禁止缩放。另外还有一种做法就是手机淘宝的做法，窗口大小是分辨率宽度，然后缩放倍数是1/devicePixelRatio，这里暂且不讨论。<br>2.就是解决安卓上的问题。经过实测，有些安卓机器，使用1的viewport，在页面刚加载的时候。不管是读取window.innerWidth，还是doc的getBoundingClientRect().width，或者是body的clientWidth，都不是设备的物理宽度。所以只好祭出黑魔法setTimeout，一试果然可以，异步100ms执行获取屏幕宽度的代码就准确了。但是这种不可控的代码让人不爽。<br>因为width=device-width initial-scale=1，documentElement的宽度又是100%，所以当这两个值相等的时候我们可以认为目前获取到的屏幕宽度是准确的。那么使用此条件作为判断条件，不断的setTimeout(fun(){}, 0)去判断，当此条件为真时改变documentElement的字体。可以尽可能快的执行目标代码。但是又万一这两个值一直不相等又不能无限的死循环下去，所以设置了一个尝试上限，到上限之后用窗口宽度来计算（缩放比例不对的话用户起码可以看到完整的页面）。在chrome下测试，执行40次代码的平均时间是230ms，考虑到安卓机的js引擎速度，将上限设为了20。<br>3.是执行时机，个人建议将这段代码放到head里，第一时间计算好html的fontSize，避免重绘。如果你有有一些跟获取dom元素尺寸相关的操作，就得放到这个计算函数的回调里面了，这时候就不能放到head里(因为运行的时候dom都还没加载)，只能放到底部或者doc的ready事件里了。最佳实践是有一个全屏的loading画面，当fontSize计算好了之后再把真正的页面展示出来。<br>网上找的 不喜勿喷！</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> WEB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于微信自定义分享的一点心得]]></title>
      <url>/2017/07/04/%E5%85%B3%E4%BA%8E%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E4%BA%AB%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97/</url>
      <content type="html"><![CDATA[<p>自从微信2017年4月份把分享接口改了之后，之前那种在页面选择第一张图片大于300px像素作为分享的默认图的方法已经失效，必须经过自定义接口来指定微信分享的图片。前几天做了一个项目，客户要求网站分享，必须要带自家的logo图片。于是查找官方api。总结一下步骤，以及步骤中可能遇到的坑。</p>
<p>1.在分享过程中，有个前提条件，由于调用微信的分享接口必须和微信的公众号进行绑定，也就是登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。此处有个坑，就是你的公众号，必须经过微信的官方认证，好像是300rmb左右，具体我也记不清，只有经过认证之后，在开发者权限里面里面，才能调用自定义接口。这就是所谓的大厂。</p>
<p>2.引入官方的微信js.<a href="http://res.wx.qq.com/open/js/jweixin-1.2.0.js" target="_blank" rel="external">http://res.wx.qq.com/open/js/jweixin-1.2.0.js</a> 跟我们平常引入的js是一样的。</p>
<p>3.通过ajax，调用后台接口（最好是json文件），来配置wx.config文件,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">var url = encodeURI(location.href.split(&apos;#&apos;)[0]);  //域名必须要去掉#号。</div><div class="line">$.ajax(&#123;  </div><div class="line">type : &quot;post&quot;,  </div><div class="line">dataType:&quot;json&quot;,</div><div class="line">data:&#123;&apos;url&apos;:url&#125;,</div><div class="line">url:&quot;&quot;.//你的后台接口地址，建议用json格式。</div><div class="line">    success:function(data)&#123;    //此处有坑，success后面的空格要去掉。不然后面莫名其妙的走不通。</div><div class="line">        console.log(data);</div><div class="line">        wx.config(&#123;  </div><div class="line">            debug: false, //调试的时候，开启，正式上线关闭，不然会在移动端弹出信息。</div><div class="line">            appId:data.appId,  // 公众号的appid、</div><div class="line">            timestamp:data.timestamp,  //时间戳 动态的。</div><div class="line">            nonceStr:data.nonceStr,   //生成签名的随机串</div><div class="line">            signature:data.signature,   // 必填，签名，</div><div class="line">            jsApiList: [      //接口数组，这儿写几个，底下就写几个。</div><div class="line">            &quot;onMenuShareTimeline&quot;, //分享给好友  </div><div class="line">            &quot;onMenuShareAppMessage&quot;, //分享到朋友圈  </div><div class="line">            &quot;onMenuShareQQ&quot;,  //分享到QQ  </div><div class="line">            ]  </div><div class="line">        &#125;);  </div><div class="line">        console.log(&quot;链接成功&quot;);</div><div class="line">        wx.ready(function()&#123;  </div><div class="line">            var shareData = &#123;  </div><div class="line">                title: &apos;&#123;&#123;title&#125;&#125;&apos; //标题,  </div><div class="line">                desc: &apos;&#123;&#123;title&#125;&#125;&apos;,//这里请特别注意是要去除html  </div><div class="line">                link: url, </div><div class="line">                imgUrl: &quot;&quot;,//图片的自定义地址。</div><div class="line">            &#125;;  </div><div class="line">            wx.onMenuShareTimeline(shareData);  </div><div class="line">            wx.onMenuShareAppMessage(shareData);  </div><div class="line">            wx.onMenuShareQQ(shareData);  </div><div class="line">    &#125;);      </div><div class="line">    &#125;,  </div><div class="line">    error:function(data)&#123;  </div><div class="line">    console.log(&quot;返回失败&quot;);</div><div class="line">    &#125;  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其余的微信的api已经讲解的很详细了。只是指出来大家少踩坑。这就是一个完整的调用微信分享的接口。上面的坑已经指出。</p>
]]></content>
      
        <categories>
            
            <category> 第三方接口 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信分享 </tag>
            
            <tag> 分享接口 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[根据验证邮箱的域名跳转到相应的登录页面]]></title>
      <url>/2017/06/29/%E6%A0%B9%E6%8D%AE%E9%AA%8C%E8%AF%81%E9%82%AE%E7%AE%B1%E7%9A%84%E5%9F%9F%E5%90%8D%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>之前由于公司项目要求，需要根据邮箱跳转到对应的邮箱，百度了半天才找到一个，不多说直接帖代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">&lt;title&gt;js邮箱地址跳转&lt;/title&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">var hash=&#123;</div><div class="line">&apos;qq.com&apos;: &apos;http://mail.qq.com&apos;,</div><div class="line">&apos;gmail.com&apos;: &apos;http://mail.google.com&apos;,</div><div class="line">&apos;sina.com&apos;: &apos;http://mail.sina.com.cn&apos;,</div><div class="line">&apos;163.com&apos;: &apos;http://mail.163.com&apos;,</div><div class="line">&apos;126.com&apos;: &apos;http://mail.126.com&apos;,</div><div class="line">&apos;yeah.net&apos;: &apos;http://www.yeah.net/&apos;,</div><div class="line">&apos;sohu.com&apos;: &apos;http://mail.sohu.com/&apos;,</div><div class="line">&apos;tom.com&apos;: &apos;http://mail.tom.com/&apos;,</div><div class="line">&apos;sogou.com&apos;: &apos;http://mail.sogou.com/&apos;,</div><div class="line">&apos;139.com&apos;: &apos;http://mail.10086.cn/&apos;,</div><div class="line">&apos;hotmail.com&apos;: &apos;http://www.hotmail.com&apos;,</div><div class="line">&apos;live.com&apos;: &apos;http://login.live.com/&apos;,</div><div class="line">&apos;live.cn&apos;: &apos;http://login.live.cn/&apos;,</div><div class="line">&apos;live.com.cn&apos;: &apos;http://login.live.com.cn&apos;,</div><div class="line">&apos;189.com&apos;: &apos;http://webmail16.189.cn/webmail/&apos;,</div><div class="line">&apos;yahoo.com.cn&apos;: &apos;http://mail.cn.yahoo.com/&apos;,</div><div class="line">&apos;yahoo.cn&apos;: &apos;http://mail.cn.yahoo.com/&apos;,</div><div class="line">&apos;eyou.com&apos;: &apos;http://www.eyou.com/&apos;,</div><div class="line">&apos;21cn.com&apos;: &apos;http://mail.21cn.com/&apos;,</div><div class="line">&apos;188.com&apos;: &apos;http://www.188.com/&apos;,</div><div class="line">&apos;foxmail.coom&apos;: &apos;http://www.foxmail.com&apos;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line">$(function()&#123;</div><div class="line">$(&quot;.mail&quot;).each(function() &#123;</div><div class="line">var url = $(this).text().split(&apos;@&apos;)[1];</div><div class="line">for (var j in hash)&#123;</div><div class="line">$(this).attr(&quot;href&quot;, hash[url]);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;)</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">  </div><div class="line">&lt;body&gt;</div><div class="line">&lt;a href=&quot;#&quot; target=&quot;_blank&quot; class=&quot;mail&quot;&gt;&lt;a href=&quot;mailto:laike@qq.com&quot;&gt;laike@qq.com&lt;/a&gt;&lt;/a&gt; &lt;br&gt;</div><div class="line">&lt;a href=&quot;#&quot; target=&quot;_blank&quot; class=&quot;mail&quot;&gt;&lt;a href=&quot;mailto:laike@gmail.com&quot;&gt;laike@gmail.com&lt;/a&gt;&lt;/a&gt; &lt;br&gt;</div><div class="line">&lt;a href=&quot;#&quot; target=&quot;_blank&quot; class=&quot;mail&quot;&gt;&lt;a href=&quot;mailto:laike@sina.com&quot;&gt;laike@sina.com&lt;/a&gt;&lt;/a&gt; &lt;br&gt;</div><div class="line">&lt;a href=&quot;#&quot; target=&quot;_blank&quot; class=&quot;mail&quot;&gt;&lt;a href=&quot;mailto:laike@163.com&quot;&gt;laike@163.com&lt;/a&gt;&lt;/a&gt; &lt;br&gt;</div><div class="line">&lt;a href=&quot;#&quot; target=&quot;_blank&quot; class=&quot;mail&quot;&gt;&lt;a href=&quot;mailto:laike@souhu.com&quot;&gt;laike@souhu.com&lt;/a&gt;&lt;/a&gt; &lt;br&gt;</div><div class="line">&lt;a href=&quot;#&quot; target=&quot;_blank&quot; class=&quot;mail&quot;&gt;&lt;a href=&quot;mailto:laike@hotmail.com&quot;&gt;laike@hotmail.com&lt;/a&gt;&lt;/a&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>之后，有大神帮忙优化调整了一下，还是那句话，直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; class=&quot;txt&quot; /&gt;</div><div class="line">&lt;a href=&quot;javascript:&quot; class=&quot;submit&quot;&gt;立即前往邮箱&lt;/a&gt;</div><div class="line">&lt;script src=&quot;http://libs.useso.com/js/jquery/1.10.0/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var hash = &#123;</div><div class="line">        &apos;qq.com&apos;: &apos;http://mail.qq.com&apos;,</div><div class="line">        &apos;gmail.com&apos;: &apos;http://mail.google.com&apos;,</div><div class="line">        &apos;sina.com&apos;: &apos;http://mail.sina.com.cn&apos;,</div><div class="line">        &apos;163.com&apos;: &apos;http://mail.163.com&apos;,</div><div class="line">        &apos;126.com&apos;: &apos;http://mail.126.com&apos;,</div><div class="line">        &apos;yeah.net&apos;: &apos;http://www.yeah.net/&apos;,</div><div class="line">        &apos;sohu.com&apos;: &apos;http://mail.sohu.com/&apos;,</div><div class="line">        &apos;tom.com&apos;: &apos;http://mail.tom.com/&apos;,</div><div class="line">        &apos;sogou.com&apos;: &apos;http://mail.sogou.com/&apos;,</div><div class="line">        &apos;139.com&apos;: &apos;http://mail.10086.cn/&apos;,</div><div class="line">        &apos;hotmail.com&apos;: &apos;http://www.hotmail.com&apos;,</div><div class="line">        &apos;live.com&apos;: &apos;http://login.live.com/&apos;,</div><div class="line">        &apos;live.cn&apos;: &apos;http://login.live.cn/&apos;,</div><div class="line">        &apos;live.com.cn&apos;: &apos;http://login.live.com.cn&apos;,</div><div class="line">        &apos;189.com&apos;: &apos;http://webmail16.189.cn/webmail/&apos;,</div><div class="line">        &apos;yahoo.com.cn&apos;: &apos;http://mail.cn.yahoo.com/&apos;,</div><div class="line">        &apos;yahoo.cn&apos;: &apos;http://mail.cn.yahoo.com/&apos;,</div><div class="line">        &apos;eyou.com&apos;: &apos;http://www.eyou.com/&apos;,</div><div class="line">        &apos;21cn.com&apos;: &apos;http://mail.21cn.com/&apos;,</div><div class="line">        &apos;188.com&apos;: &apos;http://www.188.com/&apos;,</div><div class="line">        &apos;foxmail.coom&apos;: &apos;http://www.foxmail.com&apos;</div><div class="line">&#125;;</div><div class="line">$(&apos;.txt&apos;).on(&apos;blur&apos;,function ()&#123;</div><div class="line">        var url = $(this).val().split(&apos;@&apos;)[1];</div><div class="line">        for (var j in hash) &#123;</div><div class="line">                $(&apos;.submit&apos;).attr(&quot;href&quot;, hash[url]);</div><div class="line">        &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>希望这篇文章能够满足大家</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> WEB </tag>
            
            <tag> 验证 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 的性能优化：加载和执行]]></title>
      <url>/2017/06/29/JavaScript-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/</url>
      <content type="html"><![CDATA[<p>随着 Web2.0 技术的不断推广，越来越多的应用使用 JavaScript 技术在客户端进行处理，从而使 JavaScript 在浏览器中的性能成为开发者所面临的最重要的可用性问题。而这个问题又因 JavaScript 的阻塞特性变的复杂，也就是说当浏览器在执行 JavaScript 代码时，不能同时做其他任何事情。本文详细介绍了如何正确的加载和执行 JavaScript 代码，从而提高其在浏览器中的性能。<br>概览<br>无论当前 JavaScript 代码是内嵌还是在外链文件中，页面的下载和渲染都必须停下来等待脚本执行完成。JavaScript 执行过程耗时越久，浏览器等待响应用户输入的时间就越长。浏览器在下载和执行脚本时出现阻塞的原因在于，脚本可能会改变页面或 JavaScript 的命名空间，它们对后面页面内容造成影响。一个典型的例子就是在页面中使用document.write()。例如清单 1<br>清单 1 JavaScript 代码内嵌示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;Source Example&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;p&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        document.write(&quot;Today is &quot; + (new Date()).toDateString());</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>当浏览器遇到script标签时，当前 HTML 页面无从获知 JavaScript 是否会向p 标签添加内容，或引入其他元素，或甚至移除该标签。因此，这时浏览器会停止处理页面，先执行 JavaScript代码，然后再继续解析和渲染页面。同样的情况也发生在使用 src 属性加载 JavaScript的过程中，浏览器必须先花时间下载外链文件中的代码，然后解析并执行它。在这个过程中，页面渲染和用户交互完全被阻塞了。</p>
<p>脚本位置<br>HTML 4 规范指出 script 标签可以放在 HTML 文档的head或body中，并允许出现多次。Web 开发人员一般习惯在 head 中加载外链的 JavaScript，接着用 link 标签用来加载外链的 CSS 文件或者其他页面信息。例如清单 2<br>清单 2 低效率脚本位置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;Source Example&lt;/title&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;script1.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;script2.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;script3.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;p&gt;Hello world!&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>然而这种常规的做法却隐藏着严重的性能问题。在清单 2 的示例中，当浏览器解析到 script标签（第 4 行）时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码，这意味着，其后的 styles.css 样式文件和body标签都无法被加载，由于body标签无法被加载，那么页面自然就无法渲染了。因此在该 JavaScript 代码完全执行完之前，页面都是一片空白。图 1 描述了页面加载过程中脚本和样式文件的下载过程。<br>图 1 JavaScript 文件的加载和执行阻塞其他文件的下载</p>
<p>我们可以发现一个有趣的现象：第一个 JavaScript 文件开始下载，与此同时阻塞了页面其他文件的下载。此外，从 script1.js 下载完成到 script2.js 开始下载前存在一个延时，这段时间正好是 script1.js 文件的执行过程。每个文件必须等到前一个文件下载并执行完成才会开始下载。在这些文件逐个下载过程中，用户看到的是一片空白的页面。<br>从 IE 8、Firefox 3.5、Safari 4 和 Chrome 2 开始都允许并行下载 JavaScript 文件。这是个好消息，因为script标签在下载外部资源时不会阻塞其他script标签。遗憾的是，JavaScript 下载过程仍然会阻塞其他资源的下载，比如样式文件和图片。尽管脚本的下载过程不会互相影响，但页面仍然必须等待所有 JavaScript 代码下载并执行完成才能继续。因此，尽管最新的浏览器通过允许并行下载提高了性能，但问题尚未完全解决，脚本阻塞仍然是一个问题。<br>由于脚本会阻塞页面其他资源的下载，因此推荐将所有script标签尽可能放到body标签的底部，以尽量减少对整个页面下载的影响。例如清单 3<br>清单 3 推荐的代码放置位置示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;Source Example&lt;/title&gt;</div><div class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;p&gt;Hello world!&lt;/p&gt;</div><div class="line">  </div><div class="line">    &lt;!-- Example of efficient script positioning --&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;script1.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;script2.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;script3.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>这段代码展示了在 HTML 文档中放置script标签的推荐位置。尽管脚本下载会阻塞另一个脚本，但是页面的大部分内容都已经下载完成并显示给了用户，因此页面下载不会显得太慢。这是优化 JavaScript 的首要规则：将脚本放在底部。</p>
<p>组织脚本<br>由于每个script标签初始下载时都会阻塞页面渲染，所以减少页面包含的script标签数量有助于改善这一情况。这不仅针对外链脚本，内嵌脚本的数量同样也要限制。浏览器在解析 HTML 页面的过程中每遇到一个script标签，都会因执行脚本而导致一定的延时，因此最小化延迟时间将会明显改善页面的总体性能。<br>这个问题在处理外链 JavaScript 文件时略有不同。考虑到 HTTP 请求会带来额外的性能开销，因此下载单个 100Kb 的文件将比下载 5 个 20Kb 的文件更快。也就是说，减少页面中外链脚本的数量将会改善性能。<br>通常一个大型网站或应用需要依赖数个 JavaScript 文件。您可以把多个文件合并成一个，这样只需要引用一个script标签，就可以减少性能消耗。文件合并的工作可通过离线的打包工具或者一些实时的在线服务来实现。<br>需要特别提醒的是，把一段内嵌脚本放在引用外链样式表的link之后会导致页面阻塞去等待样式表的下载。这样做是为了确保内嵌脚本在执行时能获得最精确的样式信息。因此，建议不要把内嵌脚本紧跟在link标签后面。</p>
<p>无阻塞的脚本<br>减少 JavaScript 文件大小并限制 HTTP 请求数在功能丰富的 Web 应用或大型网站上并不总是可行。Web 应用的功能越丰富，所需要的 JavaScript 代码就越多，尽管下载单个较大的 JavaScript 文件只产生一次 HTTP 请求，却会锁死浏览器的一大段时间。为避免这种情况，需要通过一些特定的技术向页面中逐步加载 JavaScript 文件，这样做在某种程度上来说不会阻塞浏览器。<br>无阻塞脚本的秘诀在于，在页面加载完成后才加载 JavaScript 代码。这就意味着在 window 对象的 onload事件触发后再下载脚本。有多种方式可以实现这一效果。<br>延迟加载脚本<br>HTML 4 为script标签定义了一个扩展属性：defer。Defer 属性指明本元素所含的脚本不会修改 DOM，因此代码能安全地延迟执行。defer 属性只被 IE 4 和 Firefox 3.5 更高版本的浏览器所支持，所以它不是一个理想的跨浏览器解决方案。在其他浏览器中，defer 属性会被直接忽略，因此script标签会以默认的方式处理，也就是说会造成阻塞。然而，如果您的目标浏览器支持的话，这仍然是个有用的解决方案。清单 4 是一个例子<br>清单 4 defer 属性使用方法示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;script1.js&quot; defer&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>带有 defer 属性的script标签可以放置在文档的任何位置。对应的 JavaScript 文件将在页面解析到script标签时开始下载，但不会执行，直到 DOM 加载完成，即onload事件触发前才会被执行。当一个带有 defer 属性的 JavaScript 文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与其他资源文件一起并行下载。<br>任何带有 defer 属性的script元素在 DOM 完成加载之前都不会被执行，无论内嵌或者是外链脚本都是如此。清单 5 的例子展示了defer属性如何影响脚本行为：<br>清单 5 defer 属性对脚本行为的影响<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;Script Defer Example&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; defer&gt;</div><div class="line">        alert(&quot;defer&quot;);</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        alert(&quot;script&quot;);</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        window.onload = function()&#123;</div><div class="line">            alert(&quot;load&quot;);</div><div class="line">        &#125;;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>这段代码在页面处理过程中弹出三次对话框。不支持 defer 属性的浏览器的弹出顺序是：“defer”、“script”、“load”。而在支持 defer 属性的浏览器上，弹出的顺序则是：“script”、“defer”、“load”。请注意，带有 defer 属性的script元素不是跟在第二个后面执行，而是在 onload 事件被触发前被调用。<br>如果您的目标浏览器只包括 Internet Explorer 和 Firefox 3.5，那么 defer 脚本确实有用。如果您需要支持跨领域的多种浏览器，那么还有更一致的实现方式。<br>HTML 5 为script标签定义了一个新的扩展属性：async。它的作用和 defer 一样，能够异步地加载和执行脚本，不因为加载脚本而阻塞页面的加载。但是有一点需要注意，在有 async 的情况下，JavaScript 脚本一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果 JavaScript 脚本前后有依赖性，使用 async 就很有可能出现错误。<br>动态脚本元素<br>文档对象模型（DOM）允许您使用 JavaScript 动态创建 HTML 的几乎全部文档内容。script元素与页面其他元素一样，可以非常容易地通过标准 DOM 函数创建：<br>清单 6 通过标准 DOM 函数创建script元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var script = document.createElement (&quot;script&quot;);</div><div class="line">   script.type = &quot;text/javascript&quot;;</div><div class="line">   script.src = &quot;script1.js&quot;;</div><div class="line">   document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</div></pre></td></tr></table></figure></p>
<p>新的script元素加载 script1.js 源文件。此文件当元素添加到页面之后立刻开始下载。此技术的重点在于：无论在何处启动下载，文件的下载和运行都不会阻塞其他页面处理过程。您甚至可以将这些代码放在head部分而不会对其余部分的页面代码造成影响（除了用于下载文件的 HTTP 连接）。<br>当文件使用动态脚本节点下载时，返回的代码通常立即执行（除了 Firefox 和 Opera，他们将等待此前的所有动态脚本节点执行完毕）。当脚本是“自运行”类型时，这一机制运行正常，但是如果脚本只包含供页面其他脚本调用调用的接口，则会带来问题。这种情况下，您需要跟踪脚本下载完成并是否准备妥善。可以使用动态 script 节点发出事件得到相关信息。<br>Firefox、Opera, Chorme 和 Safari 3+会在script节点接收完成之后发出一个 onload 事件。您可以监听这一事件，以得到脚本准备好的通知：<br>清单 7 通过监听 onload 事件加载 JavaScript 脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var script = document.createElement (&quot;script&quot;)</div><div class="line">script.type = &quot;text/javascript&quot;;</div><div class="line">  </div><div class="line">//Firefox, Opera, Chrome, Safari 3+</div><div class="line">script.onload = function()&#123;</div><div class="line">    alert(&quot;Script loaded!&quot;);</div><div class="line">&#125;;</div><div class="line">  </div><div class="line">script.src = &quot;script1.js&quot;;</div><div class="line">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</div></pre></td></tr></table></figure></p>
<p>Internet Explorer 支持另一种实现方式，它发出一个 readystatechange 事件。script元素有一个 readyState 属性，它的值随着下载外部文件的过程而改变。readyState 有五种取值：<br>“uninitialized”：默认状态<br>“loading”：下载开始<br>“loaded”：下载完成<br>“interactive”：下载完成但尚不可用<br>“complete”：所有数据已经准备好</p>
<p>微软文档上说，在script元素的生命周期中，readyState 的这些取值不一定全部出现，但并没有指出哪些取值总会被用到。实践中，我们最感兴趣的是“loaded”和“complete”状态。Internet Explorer 对这两个 readyState 值所表示的最终状态并不一致，有时script元素会得到“loader”却从不出现“complete”，但另外一些情况下出现“complete”而用不到“loaded”。最安全的办法就是在 readystatechange 事件中检查这两种状态，并且当其中一种状态出现时，删除 readystatechange 事件句柄（保证事件不会被处理两次）：<br>清单 8 通过检查 readyState 状态加载 JavaScript 脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var script = document.createElement(&quot;script&quot;)</div><div class="line">script.type = &quot;text/javascript&quot;;</div><div class="line">  </div><div class="line">//Internet Explorer</div><div class="line">script.onreadystatechange = function()&#123;</div><div class="line">     if (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;)&#123;</div><div class="line">           script.onreadystatechange = null;</div><div class="line">           alert(&quot;Script loaded.&quot;);</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line">script.src = &quot;script1.js&quot;;</div><div class="line">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</div></pre></td></tr></table></figure></p>
<p>大多数情况下，您希望调用一个函数就可以实现 JavaScript 文件的动态加载。下面的函数封装了标准实现和 IE 实现所需的功能：<br>清单 9 通过函数进行封装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function loadScript(url, callback)&#123;</div><div class="line">    var script = document.createElement (&quot;script&quot;)</div><div class="line">    script.type = &quot;text/javascript&quot;;</div><div class="line">    if (script.readyState)&#123; //IE</div><div class="line">        script.onreadystatechange = function()&#123;</div><div class="line">            if (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;)&#123;</div><div class="line">                script.onreadystatechange = null;</div><div class="line">                callback();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125; else &#123; //Others</div><div class="line">        script.onload = function()&#123;</div><div class="line">            callback();</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    script.src = url;</div><div class="line">    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此函数接收两个参数：JavaScript 文件的 URL，和一个当 JavaScript 接收完成时触发的回调函数。属性检查用于决定监视哪种事件。最后一步，设置 src 属性，并将script元素添加至页面。此 loadScript() 函数使用方法如下：<br>清单 10 loadScript()函数使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">loadScript(&quot;script1.js&quot;, function()&#123;</div><div class="line">    alert(&quot;File is loaded!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>您可以在页面中动态加载很多 JavaScript 文件，但要注意，浏览器不保证文件加载的顺序。所有主流浏览器之中，只有 Firefox 和 Opera 保证脚本按照您指定的顺序执行。其他浏览器将按照服务器返回它们的次序下载并运行不同的代码文件。您可以将下载操作串联在一起以保证他们的次序，如下：<br>清单 11 通过 loadScript()函数加载多个 JavaScript 脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">loadScript(&quot;script1.js&quot;, function()&#123;</div><div class="line">    loadScript(&quot;script2.js&quot;, function()&#123;</div><div class="line">        loadScript(&quot;script3.js&quot;, function()&#123;</div><div class="line">            alert(&quot;All files are loaded!&quot;);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>此代码等待 script1.js 可用之后才开始加载 script2.js，等 script2.js 可用之后才开始加载 script3.js。虽然此方法可行，但如果要下载和执行的文件很多，还是有些麻烦。如果多个文件的次序十分重要，更好的办法是将这些文件按照正确的次序连接成一个文件。独立文件可以一次性下载所有代码（由于这是异步进行的，使用一个大文件并没有什么损失）。<br>[size=1.166em]动态脚本加载是非阻塞 JavaScript 下载中最常用的模式，因为它可以跨浏览器，而且简单易用。<br>使用 XMLHttpRequest(XHR)对象<br>此技术首先创建一个 XHR 对象，然后下载 JavaScript 文件，接着用一个动态 script 元素将 JavaScript 代码注入页面。清单 12 是一个简单的例子：<br>清单 12 通过 XHR 对象加载 JavaScript 脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.open(&quot;get&quot;, &quot;script1.js&quot;, true);</div><div class="line">xhr.onreadystatechange = function()&#123;</div><div class="line">    if (xhr.readyState == 4)&#123;</div><div class="line">        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304)&#123;</div><div class="line">            var script = document.createElement (&quot;script&quot;);</div><div class="line">            script.type = &quot;text/javascript&quot;;</div><div class="line">            script.text = xhr.responseText;</div><div class="line">            document.body.appendChild(script);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure></p>
<p>此代码向服务器发送一个获取 script1.js 文件的 GET 请求。onreadystatechange 事件处理函数检查 readyState 是不是 4，然后检查 HTTP 状态码是不是有效（2XX 表示有效的回应，304 表示一个缓存响应）。如果收到了一个有效的响应，那么就创建一个新的script元素，将它的文本属性设置为从服务器接收到的 responseText 字符串。这样做实际上会创建一个带有内联代码的script元素。一旦新script元素被添加到文档，代码将被执行，并准备使用。<br>这种方法的主要优点是，您可以下载不立即执行的 JavaScript 代码。由于代码返回在script标签之外（换句话说不受script标签约束），它下载后不会自动执行，这使得您可以推迟执行，直到一切都准备好了。另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。<br>[size=1.166em]此方法最主要的限制是：JavaScript 文件必须与页面放置在同一个域内，不能从 CDN 下载（CDN 指”内容投递网络（Content Delivery Network）”，所以大型网页通常不采用 XHR 脚本注入技术。<br>总结<br>减少 JavaScript 对性能的影响有以下几种方法：<br>将所有的script标签放到页面底部，也就是闭合标签之前，这能确保在脚本执行前页面已经完成了渲染。<br>尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。<br>采用无阻塞下载 JavaScript 脚本的方法：</p>
<p>使用script标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）；<br>使用动态创建的script元素来下载并执行代码；<br>使用 XHR 对象下载 JavaScript 代码并注入页面中。</p>
<p>通过以上策略，可以在很大程度上提高那些需要使用大量 JavaScript 的 Web 网站和应用的实际性能。</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> WEB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信6.0之后，分享到朋友圈新方法]]></title>
      <url>/2017/06/29/%E5%BE%AE%E4%BF%A16-0%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%88%86%E4%BA%AB%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88%E6%96%B0%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>微信6.0之后，原有的WeixinJSBridge.on(‘menu:share:timeline’, function (argv) {}不再可以使用，但是微信提供的新的方法 JS-SDK, 官方接口请参见 微信JSSDK说明文档 ，具体的方法官方文档都说的比较清楚了，本文只是记录下开发过程中遇到的问题以及解决方式。</p>
<ol>
<li>虽然微信提供了JSSDK，但是这不意味着你可以用自定义的按钮来直接打开微信的分享界面，这套JSSDK只是把微信分享接口的内容定义好了，实际还是需要用户点击右上角的菜单按钮进行主动的分享，用户点开分享界面之后，出现的内容就会是你定义的分享标题、图片和链接。</li>
<li>wx.config()注入配置成功之后，会触发wx.ready()函数（同样失败的时候会触发wx.error()函数），所以之后的有必要的接口调用，比如定义分享到朋友圈、分享给好友的内容，还是放在wx.ready()中进行调用以保证正确性。<br>3.wx.checkJsApi无需wx.config即可调用，用来判断当前客户端是否能支持微信JSSDK的接口。<br>4.分享出去的链接，会被微信在链接后面追加参数。这个问题十分重要，本人在开发过程中，第一次分享出去，成功没有任何问题，但是再次打开链接，会提示invalid signature，也就是签名错误，这个问题出现的原因，就是因为原来链接的被追加了参数，传递到自己服务器后台的页面原地址和提交给微信的页面原地址不匹配，解决方法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;font color=&quot;#000&quot;&gt;&lt;font face=&quot;Arial&quot;&gt;var pageUrl = window.location.href.split(&apos;#&apos;)[0];</div><div class="line">pageUrl = pageUrl.replace(/\&amp;/g, &apos;%26&apos;);&lt;/span&gt;</div><div class="line">initJsApiTicket(pageUrl, function (data) &#123;</div><div class="line">    if (data.errcode == &apos;0&apos;) &#123;</div><div class="line">        wx.config(&#123;</div><div class="line">            debug: false,</div><div class="line">            appId: data.appId,</div><div class="line">            timestamp: data.timestamp,</div><div class="line">            nonceStr: data.nonceStr,</div><div class="line">            signature: data.signature,</div><div class="line">            jsApiList: [&apos;onMenuShareTimeline&apos;, &apos;onMenuShareAppMessage&apos;]</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);&lt;/font&gt;&lt;/font&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注意如果你是用这种方式将页面原地址作为参数传递到后台的话，需要将参数中的&amp;全部替换为%26，否则后台接收到的地址会丢失参数，导致最后签名不一致。另外，在你分享出去的URL中，必须将微信附加的参数去掉，否则会导致第二次分享成功，但是第三次、第四次以及后续的分享都失败。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">wx.ready(function () &#123;</div><div class="line">    pageUrl = pageUrl.substr(0, pageUrl.indexOf(&apos;%26&apos;));</div><div class="line">    wx.onMenuShareTimeline(&#123;</div><div class="line">        title: &apos;胶囊内镜检查图片&apos;, // 分享标题</div><div class="line">        link: pageUrl, // 分享链接</div><div class="line">        imgUrl: &apos;http://escloud-media.oss-cn-hangzhou.aliyuncs.com/escloud/newsmsg-small.png&apos;, // 分享图标</div><div class="line">        success: function () &#123;</div><div class="line">            // 用户确认分享后执行的回调函数</div><div class="line">     &#125;,</div><div class="line">     cancel: function () &#123;</div><div class="line">         // 用户取消分享后执行的回调函数</div><div class="line">     &#125;,</div><div class="line">     fail: function (res) &#123;</div><div class="line">         alert(&quot;分享失败，请重新尝试&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    wx.onMenuShareAppMessage(&#123;</div><div class="line">        title: &apos;胶囊内镜检查图片&apos;, // 分享标题</div><div class="line">        desc: &apos;胶囊内镜检查图片&apos;, // 分享描述</div><div class="line">        link: pageUrl, // 分享链接</div><div class="line">        imgUrl: &apos;http://escloud-media.oss-cn-hangzhou.aliyuncs.com/escloud/newsmsg-small.png&apos;, // 分享图标</div><div class="line">        type: &apos;link&apos;, // 分享类型,music、video或link，不填默认为link</div><div class="line">        dataUrl: &apos;&apos;, // 如果type是music或video，则要提供数据链接，默认为空</div><div class="line">        success: function () &#123;</div><div class="line">            // 用户确认分享后执行的回调函数</div><div class="line">        &#125;,</div><div class="line">        cancel: function () &#123;</div><div class="line">            // 用户取消分享后执行的回调函数</div><div class="line">        &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 第三方接口 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
            <tag> WEB </tag>
            
            <tag> 技术分享 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网页设计：色彩搭配原则及方法]]></title>
      <url>/2017/06/28/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%EF%BC%9A%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D%E5%8E%9F%E5%88%99%E5%8F%8A%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在这一篇中将介绍色彩搭配原则和方法！<br>一、色彩搭配原则<br>在选择网页色彩时，除了考虑网站本身的特点外还要遵循一定的艺术规律，从而设计出精美的网页。<br>1.色彩的鲜明性：<br>如果一个网站的色彩鲜明，很容易引人注意，会给浏览者耳目一新的感觉。<br>2.色彩的独特性：<br>要有与众不同色彩，网页的用色必须要有自己独特的风格，这样才能给人浏览者留下深刻的印象。<br>3.色彩的艺术性：<br>网站设计是一种艺术活动，因此必须遵循艺术规律。按照内容决定形式的原则，在考虑网站本身特点的同时，大胆进行艺术创新，设计出既符合网站要求，又具有一定艺术特色的网站。<br>4.色彩搭配的合理性：<br>色彩要根据主题来确定，不同的主题选用不同的色彩。例如，用蓝色体现科技型网站的专业，用粉红色体现女性的柔情等。<br>二、网页色彩搭配方法<br>网页配色很重要，网页颜色搭配的是否合理会直接影响到访问者的情绪。好的色彩搭配会给访问者带来很强的视觉冲击力，不恰当的色彩搭配则会让访问者浮躁不安。<br>1.同种色彩搭配：<br>同种色彩搭配是指首先选定一种色彩，然后调整其透明度和饱和度，将色彩变淡或加深，而产生新的色彩，这样的页面看起来色彩统一，具有层次感。<br>2.邻近色彩搭配：<br>邻近色是指在色环上相邻的颜色，如绿色和蓝色、红色和黄色即互为邻近色。采用邻近色搭配可以里是网页避免色彩杂乱，易于达到页面和谐统一的效果。<br>3.对比色彩搭配：<br>一般来说，色彩的三原色（红、黄、蓝）最能体现色彩间的差异。色彩的强烈对比具有视觉诱惑力，能够起到几种实现的作用。对比色可以突出重点，产生强烈的视觉效果。通过合理使用对比色，能够使网站特色鲜明、重点突出。在设计时，通常以一种颜色为主色调，其对比色作为点缀，以起到画龙点睛的作用。<br>4.暖色色彩搭配：<br>暖色色彩搭配是指使用红色橙色黄色集合色等色彩的搭配。这种色调的运用可为网页营造出稳性、和谐和热情的氛围。<br>5.冷色色彩搭配：<br>冷色色彩搭配是指使用绿色、蓝色及紫色等色彩的搭配，这种色彩搭配可为网页营造出宁静、清凉和高雅的氛围。冷色点色彩与白色搭配一般会获得较好的视觉效果。<br>6.有主色的混合色彩搭配：<br>有主色的混合色彩搭配是指以一种颜色作为主要颜色，同色辅以其他色彩混合搭配，形成缤纷而不杂乱的搭配效果。<br>7.文字与网页的背景色对比要突出：<br>文字内容的颜色与网页的背景色对比要突出，底色深，文字的颜色就应浅，以深色的背景衬托浅色的内容（文字或图片）；反之，底色淡，文字的颜色就要深些，以浅色的背景衬托深色的内容（文字或图片）。</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> 网页设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跨浏览器兼容实现首段首字下沉效果的CSS代码]]></title>
      <url>/2017/06/28/%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E5%AE%9E%E7%8E%B0%E9%A6%96%E6%AE%B5%E9%A6%96%E5%AD%97%E4%B8%8B%E6%B2%89%E6%95%88%E6%9E%9C%E7%9A%84CSS%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>之前有朋友问过类似的问题，找了找相关的资料，找到了，分享一下，希望能帮助大家！<br>CSS代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.parent_class&gt;p:first-child:first-letter&#123; </div><div class="line">font-size:2.5em; </div><div class="line">padding:5px 5px 0 0; </div><div class="line">float:left; </div><div class="line">font-family:楷体,楷体_GB2312; </div><div class="line">font-weight:bold; </div><div class="line">color:#E6192C; </div><div class="line">line-height:1.2em; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中.parent_class为p标签的父级元素，最后一行指定行高为了兼容IE，否则ie显示会错位。字体的话，好像在xp下，用“楷体”不能识别，必须用“楷体_GB2312”，而win7下正常。其它内容可按需要更改为你想要的效果。</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[火狐CSS hack -moz]]></title>
      <url>/2017/06/28/%E7%81%AB%E7%8B%90CSS-hack-moz/</url>
      <content type="html"><![CDATA[<p>-moz火狐CSS hack  </p>
<p>Mozilla浏览器支持一些扩展的CSS是以-moz开头的。这些措施包括了一些功能，包括圆形边界，并能够指定不同的方块的宽度和高度的计算，在非标准方式下，这种css在Mozilla浏览器下执行计算更容易得到支持。 </p>
<p>有些特性在后来被提议列入的CSS规范，但标准的属性与-moz属性还是有些不同。 </p>
<p>其中一些非标准属性只适用于Mozilla浏览器。</p>
<p>At-rules</p>
<ul>
<li>@-moz-document</li>
</ul>
<p>Pseudo-elements and pseudo-classes</p>
<ul>
<li>:-moz-list-bullet控制list-style的大小。</li>
<li>:-moz-first-node伪对象：第一个节点。</li>
<li>:-moz-last-node 伪对象：最后一个节点。</li>
<li>:-moz-only-whitespace伪对象：空白内容。</li>
<li>:-moz-bound-element</li>
<li>:-moz-any-link (matches :link and :visited)</li>
<li>:-moz-drag-over</li>
<li>:-moz-tree-row</li>
<li>:-moz-tree-row(hover) New in Firefox 3</li>
<li>:-moz-tree-cell</li>
<li>:-moz-tree-checkbox</li>
<li>:-moz-tree-column</li>
<li>:-moz-tree-cell-text</li>
<li>:-moz-tree-cell-text(hover) New in Firefox 3</li>
<li>:-moz-tree-twisty</li>
<li>:-moz-tree-indentation</li>
<li>:-moz-tree-line</li>
<li>:-moz-tree-image</li>
<li>:-moz-tree-separator</li>
<li>:-moz-tree-drop-feedback</li>
<li>:-moz-tree-progressmeter</li>
<li>:-moz-system-metric(windows-default-theme) New in Firefox 3</li>
<li>:-moz-system-metric(mac-graphite-theme) New in Firefox 3.1 bug 448767</li>
<li>:-moz-system-metric(images-in-menus) New in Firefox 3</li>
<li>:-moz-system-metric(scrollbar-start-backward) New in Firefox 3</li>
<li>:-moz-system-metric(scrollbar-start-forward) New in Firefox 3</li>
<li>:-moz-system-metric(scrollbar-end-backward) New in Firefox 3</li>
<li>:-moz-system-metric(scrollbar-end-forward) New in Firefox 3</li>
<li>:-moz-system-metric(scrollbar-thumb-proportional) New in Firefox 3</li>
<li>:-moz-alt-text New in Firefox 3</li>
<li>:-moz-placeholder New in Firefox 3</li>
<li>:-moz-broken New in Firefox 3</li>
<li>::-moz-svg-foreign-content</li>
<li>::-moz-scrolled-page-sequence</li>
<li>::-moz-scrolled-content</li>
<li>::-moz-anonymous-block</li>
<li>::-moz-cell-content</li>
<li>::-moz-anonymous-positioned-block</li>
<li>::-moz-pagecontent</li>
<li>::-moz-page</li>
<li>::-moz-page-sequence</li>
<li>::-moz-pagebreak</li>
<li>::-moz-viewport</li>
<li>::-moz-viewport-scroll</li>
<li>::-moz-canvas</li>
<li>::-moz-scrolled-canvas</li>
<li>::-moz-xul-anonymous-block</li>
<li>::-moz-table</li>
<li>::-moz-table-cell</li>
<li>::-moz-table-row-group</li>
<li>::-moz-table-column-group</li>
<li>::-moz-table-column</li>
<li>::-moz-table-row</li>
<li>::-moz-table-outer</li>
<li>::-moz-inline-table</li>
</ul>
<p>Properties</p>
<ul>
<li>-moz-appearance</li>
<li>-moz-binding</li>
<li>-moz-background-clip</li>
<li>-moz-background-inline-policy</li>
<li>-moz-background-origin</li>
<li>-moz-border-image New in Firefox 3.1 bug 378217</li>
<li>-moz-border-top-colors</li>
<li>-moz-border-right-colors</li>
<li>-moz-border-bottom-colors</li>
<li>-moz-border-left-colors</li>
<li>-moz-border-radius</li>
<li>-moz-border-radius-topleft</li>
<li>-moz-border-radius-topright</li>
<li>-moz-border-radius-bottomleft</li>
<li>-moz-border-radius-bottomright</li>
<li>-moz-box-align</li>
<li>-moz-box-direction</li>
<li>-moz-box-flex</li>
<li>-moz-box-ordinal-group</li>
<li>-moz-box-orient</li>
<li>-moz-box-pack</li>
<li>-moz-box-shadow New in Firefox 3.1 bug 212633</li>
<li>-moz-box-sizing</li>
<li>-moz-image-region</li>
<li>-moz-box-flexgroup</li>
<li>-moz-opacity Obsolete</li>
<li>-moz-outline Deprecated</li>
<li>-moz-outline-color Deprecated</li>
<li>-moz-outline-offset</li>
<li>-moz-outline-radius</li>
<li>-moz-outline-radius-topleft</li>
<li>-moz-outline-radius-topright</li>
<li>-moz-outline-radius-bottomleft</li>
<li>-moz-outline-radius-bottomright</li>
<li>-moz-outline-style Deprecated</li>
<li>-moz-outline-width Deprecated</li>
<li>-moz-user-focus</li>
<li>-moz-user-input</li>
<li>-moz-user-modify</li>
<li>-moz-user-select</li>
<li><p>-moz-window-shadow New in Firefox 3.1 bug 450939</p>
</li>
<li><p>CSS3 Box<br>o overflow-x<br>o overflow-y</p>
</li>
<li><p>CSS3 Columns<br>o -moz-column-count<br>o -moz-column-gap<br>o -moz-column-width<br>o -moz-column-rule New in Firefox 3.1 bug 271586<br>o -moz-column-rule-width New in Firefox 3.1 bug 271586<br>o -moz-column-rule-style New in Firefox 3.1 bug 271586<br>o -moz-column-rule-color New in Firefox 3.1 bug 271586</p>
</li>
<li><p>CSS transforms<br>o -moz-transform New in Firefox 3.1<br>o -moz-transform-origin New in Firefox 3.1</p>
</li>
<li><p>-moz-float-edge</p>
</li>
<li>-moz-border-end</li>
<li>-moz-border-end-color</li>
<li>-moz-border-end-style</li>
<li>-moz-border-end-width</li>
<li>-moz-border-start bug 74880</li>
<li>-moz-border-start-color</li>
<li>-moz-border-start-style</li>
<li>-moz-border-start-width</li>
<li>-moz-margin-end</li>
<li>-moz-margin-start</li>
<li>-moz-padding-start</li>
<li>-moz-padding-end</li>
<li>-moz-force-broken-image-icon</li>
<li>-moz-stack-sizing New in Firefox 3.1</li>
</ul>
<p>Values</p>
<ul>
<li><p>cursor<br>o -moz-alias<br>o -moz-cell<br>o -moz-context-menu<br>o -moz-copy<br>o -moz-grab<br>o -moz-grabbing<br>o -moz-spinning<br>o -moz-zoom-in<br>o -moz-zoom-out</p>
</li>
<li><p>display<br>o -moz-box<br>o -moz-inline-block<br>o -moz-inline-box<br>o -moz-inline-grid<br>o -moz-inline-stack<br>o -moz-inline-table<br>o -moz-grid<br>o -moz-grid-group<br>o -moz-grid-line<br>o -moz-groupbox<br>o -moz-deck<br>o -moz-popup<br>o -moz-stack<br>o -moz-run-in<br>o -moz-compact<br>o -moz-marker</p>
</li>
<li><p>overflow<br>o -moz-scrollbars-horizontal<br>o -moz-scrollbars-none<br>o -moz-scrollbars-vertical<br>o -moz-hidden-unscrollable</p>
</li>
</ul>
<p>Note: All of these values should be considered deprecated. Use of the overflow-x and overflow-y is preferred, although it does not replace the last of these.</p>
<ul>
<li><p>border-style and outline-style<br>o -moz-bg-inset - Makes the inset border to blend with then current background (scheduled for removal bug 84307 )<br>o -moz-bg-outset - Makes the outset border to blend with then current background (scheduled for removal bug 84307 )<br>o -moz-bg-solid - Makes the solid border to blend with then current background (scheduled for removal bug 84307 )</p>
</li>
<li><p>border-color<br>o -moz-use-text-color</p>
</li>
<li><p>For all properties accepting color keywords<br>o -moz-activehyperlinktext<br>o -moz-hyperlinktext<br>o -moz-visitedhyperlinktext<br>o -moz-buttondefault<br>o -moz-buttonhoverface<br>o -moz-buttonhovertext<br>o -moz-cellhighlight<br>o -moz-cellhighlighttext<br>o -moz-field<br>o -moz-fieldtext<br>o -moz-dialog<br>o -moz-dialogtext<br>o -moz-dragtargetzone<br>o -moz-mac-accentdarkestshadow<br>o -moz-mac-accentdarkshadow<br>o -moz-mac-accentface<br>o -moz-mac-accentlightesthighlight<br>o -moz-mac-accentlightshadow<br>o -moz-mac-accentregularhighlight<br>o -moz-mac-accentregularshadow<br>o -moz-mac-chrome-active New in Firefox 3.1 bug 449833<br>o -moz-mac-chrome-inactive New in Firefox 3.1 bug 449833<br>o -moz-mac-focusring<br>o -moz-mac-menuselect<br>o -moz-mac-menushadow<br>o -moz-mac-menutextselect<br>o -moz-menuhover<br>o -moz-menuhovertext<br>o -moz-win-communicationstext New in Firefox 3<br>o -moz-win-mediatext New in Firefox 3<br>o -moz-nativehyperlinktext New in Firefox 3.1 bug 426732</p>
</li>
<li><p>empty-cells<br>o -moz-show-background (default value in quirks mode)</p>
</li>
<li><p>font-family<br>o -moz-fixed</p>
</li>
<li><p>font<br>o -moz-button<br>o -moz-info<br>o -moz-desktop<br>o -moz-dialog (also a color)<br>o -moz-document<br>o -moz-workspace<br>o -moz-window<br>o -moz-list<br>o -moz-pull-down-menu<br>o -moz-field (also a color)</p>
</li>
<li><p>text-align<br>o -moz-center<br>o -moz-left<br>o -moz-right</p>
</li>
<li><p>text-decoration<br>o -moz-anchor-decoration</p>
</li>
<li><p>-moz-user-select<br>o -moz-all<br>o -moz-none</p>
</li>
<li><p>list-style-type<br>o -moz-arabic-indic<br>o -moz-bengali<br>o -moz-cjk-earthly-branch<br>o -moz-cjk-heavenly-stem<br>o -moz-devanagari<br>o -moz-ethiopic-halehame<br>o -moz-ethiopic-halehame-am<br>o -moz-ethiopic-halehame-ti-er<br>o -moz-ethiopic-halehame-ti-et<br>o -moz-ethiopic-numeric<br>o -moz-gujarati<br>o -moz-gurmukhi<br>o -moz-hangul<br>o -moz-hangul-consonant<br>o -moz-japanese-formal<br>o -moz-japanese-informal<br>o -moz-kannada<br>o -moz-khmer<br>o -moz-lao<br>o -moz-malayalam<br>o -moz-myanmar<br>o -moz-oriya<br>o -moz-persian<br>o -moz-simp-chinese-formal<br>o -moz-simp-chinese-informal<br>o -moz-tamil<br>o -moz-telugu<br>o -moz-thai<br>o -moz-trad-chinese-formal<br>o -moz-trad-chinese-informal<br>o -moz-urdu</p>
</li>
<li><p>width , min-width , max-width (see bug 311415 )<br>o -moz-min-content New in Firefox 3<br>o -moz-fit-content New in Firefox 3<br>o -moz-max-content New in Firefox 3<br>o -moz-available New in Firefox 3</p>
</li>
<li><p>-moz-appearance<br>o -moz-win-browsertabbar-toolbox New in Firefox 3<br>o -moz-win-communications-toolbox New in Firefox 3<br>o -moz-win-media-toolbox New in Firefox 3<br>o -moz-mac-unified-toolbar New in Firefox 3.1</p>
</li>
</ul>
<p>Others</p>
<ul>
<li><p>color ‘functions’<br>o -moz-hsla (hue, saturation, lightness, opacity)<br>o -moz-rgba</p>
</li>
<li><p>-moz-initial - The value -moz-initial is a partial implementation of css3’s initial used to apply the CSS specification’s initial value of a property to an element.</p>
</li>
<li><p>-moz-math-columnline</p>
</li>
<li>-moz-math-firstcolumn</li>
<li>-moz-math-firstrow</li>
<li>-moz-math-font-size</li>
<li>-moz-math-font-style</li>
<li>-moz-math-lastcolumn</li>
<li>-moz-math-lastrow</li>
<li>-moz-math-rowline</li>
</ul>
<p>CSS Transforms</p>
<p>From CSS Transforms spec (Webkit)</p>
<ul>
<li>-moz-transform CSS Transforms introduction New in Firefox 3.1 bug 435293</li>
<li>-moz-transform-origin New in Firefox 3.1 bug 435293</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS样式规范]]></title>
      <url>/2017/06/28/CSS%E6%A0%B7%E5%BC%8F%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<p>页面制作思想原则<br>    始终保证HTML、CSS的轻量化，把复杂的事情简单化，把简单的事情模块化，用尽可能简洁的代码实现所需的页面。</p>
<p>页面制作布局规范<br>    1．页面title格式<br>        以下划线（<em>）分割，格式：内容标题</em>栏目标题</p>
<pre><code>2．页面分为Layout和Block两大类
    Layout部分负责限定总体尺寸及构建页面基本轮廓。
    Block部份依实际内容分别定制最外层以div标签包裹，尺寸一般不做限定，模块尽量设置overflow样式以控制出错成本。

3．关于重用
    当页面中相似模块较多时，可考虑将其结构制作成公用模块，以方便重用。
    重用模块主要以结构重用为目的，对于模块中的文字、链接等细节等的处理，可以通过给其附加额外的class进行扩展。
</code></pre><p>样式命名及参数规范<br>       1．一律采用px为数值单位<br>       2．按钮以btn<em>开头命名<br>       3．图标以ico</em>开头命名<br>       4．Layout模块的样式以la<em>为前缀命名。<br>       5．重用模块的命名以前缀re</em>开头以方便识别，重用样式建立修改必需慎重。<br>       6．样式继承的起始为点为该标签所在的Block，继承层级尽量控制在4个以内。<br>       7．样式套用顺序：重用样式 预置样式 私有样式。<br>       8．样式名以前缀+Camel风格命名，例：la_showDemo<br>       9．大型项目时可考虑给body设置class以提供额外的全局判断，利于细节扩展。</p>
<p>图片文件命名整合规范<br>    1.临时文件以下划线开头(_)开头，应确保在任何情况下该文件被删除时都不会影响到网页的设计需求。例：<em>photo.jpg<br>    2.背景图片以bg</em>开头来命名<br>        a．大图独立命名，体积以控制在70KB以内为宜。<br>        b．有固定宽高之一的平铺图片根据轴向以bg_x.jpg或bg<em>y.jpg命名整合在一起，以1px不同色块间隔，存储成质量为100的jpg。<br>        （考虑到平铺图片的特性，若有尺寸上的修改，原则上以删除旧图，在图片末尾处添加新图为准，不要试图在原处修改，以免出现管理混乱。）<br>        c．有延伸要求的平铺图片务必独立命名，不可贪图方便整合进其他图片。格式为：前缀</em>轴向_实例名。例：bg_x<em>page.jpg<br>    3．网站常规的样式图片可根据需求选择jpg或gif格式，以img.jpg或img.gif命名。<br>    4．gif动画文件需同类整合，以m</em>为前缀，注意控制图片体积。<br>    5．现阶段尽量不用png。</p>
<p>常用hack<br>    注意：良好的结构比任何hack都好，尽量少用。<br>    width:1px;*width:1px;_width:1px;  ff,ie7,ie6</p>
<p>附表<br>    复制内容到剪贴板<br>    代码:<br>    样式命名规范表<br>    类型    前缀    命名示例<br>    网页结构    la_    la<em>showDemo<br>    普通模块    无    showDemo<br>    重用模块    re</em>    re<em> showDemo<br>    图标    ico</em>    ico<em> showDemo<br>    按钮    btn</em>    btn<em> showDemo<br>    复制内容到剪贴板<br>    代码:<br>    图片命名规范表<br>    类型    规范    命名示例<br>    普通图片    无    photo.jpg<br>    整合图片    img+数字(可选)    img.gif | img1.gif<br>    gif动画    m</em>前缀    m<em>ico.gif<br>    大尺寸背景图    bg</em>命名    bg<em>top.jpg<br>    平铺图片（限定）    bg</em>轴向    bg<em>x.jpg<br>    平铺图片（延伸）    bg</em>轴向_命名    bg_x<em>page.jpg<br>    临时图片    </em>    _photo.jpg</p>
]]></content>
      
        <categories>
            
            <category> 前端学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WEB </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[欢迎]]></title>
      <url>/2017/06/28/%E6%AC%A2%E8%BF%8E/</url>
      <content type="html"><![CDATA[<p>大家好，非常欢迎大家浏览我的技术博客，希望这些资料能够帮主大家，同时我希望大家能够帮忙分享，这样可以帮助更多的朋友！</p>
<p>Hello everyone, very welcome to visit my technology blog, I hope this information can help the Lord, and I hope we can help to share, so you can help more friends!</p>
]]></content>
      
        <categories>
            
            <category> 其他 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 欢迎，关于 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
